{"Description":"","Items":[{"Categories":[],"Content":"<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\">CubePDF 1.0.0RC12<\/a> をリリースしました。このバージョンでは大幅な修正を実施しました。<\/p>\u000a\u000a<h4>CubePDF メイン画面の UI 見直し<\/h4>\u000a\u000a<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191101\/20191101110855.png\" alt=\"CubePDF メイン画面\" \/><\/a><\/p>\u000a\u000a<p>CubePDF 1.0.0RC12 では、メイン画面の UI に関して全体的な見直しを行いました。まず、メイン画面のタイトルバーに、印刷時に指定された「ドキュメント名」を表示するように修正しました。CubePDF 1.0.0RC11 において、印刷時の挙動を変更した事により CubePDF のメイン画面が複数個表示される可能性がありますが、これまでの形では、どの画面がどの印刷データに対応しているのか分かりづらいと言う問題がありました。そこで、CubePDF 1.0.0RC12 では、この問題を軽減するためにタイトルバーにドキュメント名を表示しています。<\/p>\u000a\u000a<p>次に、「ページの向き」および「ポストプロセス」を「一般」タブに表示するように修正しました。また、「ポストプロセス」に関しては、初期設定でユーザによる任意のプログラムを実行できる形に修正しています。変換完了後に何らかのプログラムを実行したい場合は、「ポストプロセス」で「その他」を選択し、実行プログラムを指定して下さい。<\/p>\u000a\u000a<p>また、「解像度」に関しては、これまでいくつかの値から選択する形となっていましたが、CubePDF 1.0.0RC12 では 72dpi ～ 6,000dpi の範囲で任意の値を設定できるように修正しました。ただし、特に画像ファイルの場合、解像度の値に応じてファイルサイズも大きくなりますので、あまり大きすぎる値には設定しないようご注意下さい。<\/p>\u000a\u000a<p>尚、「フォントを埋め込む」機能に関しては、フォントを埋め込まない場合に（フォントがインストールされているにも関わらず）文字化けが発生すると言う不都合が発見されて以降、選択項目を無効（強制的に埋め込み）にしていましたが、残念ながら現時点ででは解決の見込みが立たない状況です。そのため、該当機能に関しては、いったん削除する事とします。将来的に、もし解決する見込みが立ちましたら、その段階で改めて機能追加と言う形で対応させて頂きますので、ご理解のほど、よろしくお願いいたします。<\/p>\u000a\u000a<h4>閲覧用パスワードに関する修正<\/h4>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191101\/20191101110906.png\" alt=\"パスワード設定\" \/><\/p>\u000a\u000a<p>いくつかの問題から、CubePDF 1.0.0RC9 にて、管理用パスワードと閲覧用パスワードを共有できる条件に制限を設けました。しかし、この設定が分かりづらいと言うご指摘をいくつか頂いたため、CubePDF 1.0.0RC12 では、表示方法を変更しました。<\/p>\u000a\u000a<h5>重要<\/h5>\u000a\u000a<p>CubePDF 1.0.0RC12 以降も、管理用パスワードと閲覧用パスワードを共有した場合、各種操作の許可・禁止設定を行う事はできません。また、Adobe Acrobat 等の PDF 閲覧ソフトで確認した所、<strong>管理用パスワードと閲覧用パスワードを共有し、該当パスワードで PDF ファイルを開いた場合、（管理用パスワードで開いたと見なされるためか）設定したパスワードの変更・除去も含め、全ての操作が可能になるようです<\/strong>。管理用パスワードと閲覧用パスワードを共有する場合は、上記の事をよく理解した上で、ご利用頂くようお願いいたします。<\/p>\u000a\u000a<h4>表示言語の設定<\/h4>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191101\/20191101110916.png\" alt=\"表示言語の設定\" \/><\/p>\u000a\u000a<p>CubePDF 1.0.0RC9 以降、メイン画面に関しては Windows の設定に応じて表示言語（日本語、または英語）を変更していましたが、CubePDF 1.0.0RC12 では、メイン画面の「その他」タブで表示言語を選択できるようになりました。また、表示言語の変更後に、「設定を保存」ボタンを押すと、次回起動以降は該当の言語で表示されるようになります。<\/p>\u000a\u000a<h4>PDF の文書プロパティに関する変更<\/h4>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191101\/20191101110926.png\" alt=\"文書プロパティの設定\" \/><\/p>\u000a\u000a<p>最後に、CubePDF 1.0.0RC12 では、PDF の文書プロパティで、「変換ソフト」と「表示オプション」が設定できるようになりました。「変換ソフト（アプリケーション）」の欄は CubePDF 1.0.0RC11 まで「CubePDF」に固定していましたが、これを任意の文字列に変更できるようになります。ただし、利用しているライブラリの都合上、「PDF 変換」の欄は、これまで通り「iTextSharp」に固定されますので、その点はご了承下さい。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/2018\/06\/26\/cubepdf-1.0.0rc12","PublishTime":"\/Date(1572574727000+0900)\/","Status":2,"Summary":"CubePDF 1.0.0RC12 をリリースしました。このバージョンでは大幅な修正を実施しました。 CubePDF メイン画面の UI 見直し CubePDF 1.0.0RC12 では、メイン画面の UI に関して全体的な見直しを行いました。まず、メイン画面のタイトルバーに、印刷時に指定された「ドキュメント名」を表示するように修正しました。CubePDF 1.0.0RC11 において、印刷時の挙","Title":"CubePDF 1.0.0RC12"},{"Categories":[],"Content":"<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191031\/20191031195611.png\" alt=\"CubePDF の脆弱性対策\" \/><\/a><\/p>\u000a\u000a<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\">CubePDF 1.0.0RC15<\/a> をリリースしました。CubePDF 1.0.0RC15 では <a href=\"https:\/\/www.ghostscript.com\/doc\/9.25\/News.htm\">Ghostscript 9.25<\/a> のバージョンアップに対応しています。Ghostscript 9.25 では、先日の脆弱性に関連する修正も含まれるようですので、CubePDF をお使いの方は、<a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\">https:\/\/www.cube-soft.jp\/cubepdf\/<\/a> より最新版への更新をお願いいたします。<\/p>\u000a\u000a<p>尚、今回の脆弱性に関する CubePDF 側の対応方法に関しては、<a href=\"https:\/\/clown.cube-soft.jp\/entry\/2018\/08\/27\/cubepdf-1.0.0rc13\">CubePDF 1.0.0RC13<\/a> を参照下さい。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/2018\/10\/01\/cubepdf-1.0.0rc15","PublishTime":"\/Date(1572519931000+0900)\/","Status":2,"Summary":"CubePDF 1.0.0RC15 をリリースしました。CubePDF 1.0.0RC15 では Ghostscript 9.25 のバージョンアップに対応しています。Ghostscript 9.25 では、先日の脆弱性に関連する修正も含まれるようですので、CubePDF をお使いの方は、https:\/\/www.cube-soft.jp\/cubepdf\/ より最新版への更新をお願いいたします。 尚","Title":"CubePDF 1.0.0RC15"},{"Categories":[],"Content":"<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191031\/20191031195611.png\" alt=\"CubePDF の脆弱性対策\" \/><\/a><\/p>\u000a\u000a<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\">CubePDF 1.0.0RC14<\/a> をリリースしました。先日、Ghostscript に存在していた脆弱性が修正された <a href=\"https:\/\/www.ghostscript.com\/doc\/9.24\/News.htm\">Ghostscript 9.24<\/a> がリリースされました。CubePDF 1.0.0RC14 は、この修正版を適用したものとなっています。尚、今回の脆弱性に関する CubePDF 側の対応方法に関しては、<a href=\"https:\/\/clown.cube-soft.jp\/entry\/2018\/08\/27\/cubepdf-1.0.0rc13\">CubePDF 1.0.0RC13<\/a> も参照下さい。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/2018\/09\/12\/cubepdf-1.0.0rc14","PublishTime":"\/Date(1572519728000+0900)\/","Status":2,"Summary":"CubePDF 1.0.0RC14 をリリースしました。先日、Ghostscript に存在していた脆弱性が修正された Ghostscript 9.24 がリリースされました。CubePDF 1.0.0RC14 は、この修正版を適用したものとなっています。尚、今回の脆弱性に関する CubePDF 側の対応方法に関しては、CubePDF 1.0.0RC13 も参照下さい。","Title":"CubePDF 1.0.0RC14"},{"Categories":[],"Content":"<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\">CubePDF 1.0.0RC13<\/a> をリリースしました。今回のアップデートは、Ghostscript の脆弱性に関連するものとなっています。<\/p>\u000a\u000a<p>先日、<a href=\"https:\/\/www.jpcert.or.jp\/at\/2018\/at180035.html\">Ghostscript の脆弱性<\/a> に関するレポートが公開されました。CubePDF は、PDF や PNG 画像などの変換処理に Ghostscript を使用しているため、この脆弱性の影響を受ける可能性があります。今回の脆弱性に関して、関連レポートなどを通じて内容の詳細を確認した所、今回の脆弱性は「Ghostscript に対して細工した PostScript ファイルを読み込ませる事で任意のコマンドを実行させる」と言うもののようです。<\/p>\u000a\u000a<p>CubePDF は、Windows 用のプリンタドライバによって生成された PostScript を変換の対象としているため、これらのデータのみを扱う限りにおいては脆弱性の影響を受ける可能性は低いと予想しています。その上で、CubePDF 1.0.0RC13 では、入力ファイルがプリンタドライバによって生成された事を保証するために、入力ファイルに対してハッシュ値による確認処理を追加しました。<\/p>\u000a\u000a<p>具体的には、下記のような流れとなります。CubePDF のプリンタモニタはプリンタドライバから PostScript （印刷データ）を受け取ると、このデータを一時ファイルに保存します。この時 CubePDF 1.0.0RC13 では、CubePDF のプリンタモニタが、保存するデータ全体に対して SHA-256 によるハッシュ値を計算し、その結果もあわせて CubePDF メインプログラム (cubepdf.exe) に指定するように修正しました。<\/p>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191031\/20191031195611.png\" alt=\"ハッシュ値が不一致の場合\" \/><\/p>\u000a\u000a<p>CubePDF メインプログラムは、ユーザによって「変換」ボタンが押されると、Ghostscript による変換が実行される直前に再度ハッシュ値を計算し、指定された値と比較します。この時、これらの値が一致しない場合は上記のようなエラーメッセージが表示され、終了します。<\/p>\u000a\u000a<p>尚、今回の脆弱性に対する最終的な対応に関しては、Ghostscript の修正を待つ事となります。Ghostscript のバージョンアップが行われたタイミングで、CubePDF も再度、次バージョンをリリースする予定ですので、しばらくお待ちください。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/2018\/08\/27\/cubepdf-1.0.0rc13","PublishTime":"\/Date(1572519439000+0900)\/","Status":2,"Summary":"CubePDF 1.0.0RC13 をリリースしました。今回のアップデートは、Ghostscript の脆弱性に関連するものとなっています。 先日、Ghostscript の脆弱性 に関するレポートが公開されました。CubePDF は、PDF や PNG 画像などの変換処理に Ghostscript を使用しているため、この脆弱性の影響を受ける可能性があります。今回の脆弱性に関して、関連レポートな","Title":"CubePDF 1.0.0RC13"},{"Categories":[],"Content":"<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\">CubePDF 1.0.0RC18<\/a> をリリースしました。修正点は下記の通りです。<\/p>\u000a\u000a<h4>文書プロパティを「設定を保存」機能の対象となるように拡張<\/h4>\u000a\u000a<p>CubePDF には「設定の保存」機能が存在しますが、この機能の対象はこれまで「一般」および「その他」タブに存在する項目に限られていました。1.0.0RC18 では、これに加えて、「文書プロパティ」タブの各項目も設定の保存機能の対象となるように修正しました。<\/p>\u000a\u000a<p>ただし、PDF の文書プロパティに関しては、「タイトル」、「作成者」、「サブタイトル」、「キーワード」のいずれかの項目が入力されている状態で「設定を保存」ボタンを押すと、以下のような警告を表示するようにしています。<\/p>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191030\/20191030135652.png\" alt=\"設定を保存実行時の警告\" \/><\/p>\u000a\u000a<p>「タイトル」や「作成者」等の内容を入力して「設定を保存」ボタンを押すと、その時点の情報が <strong>次回以降に作成する PDF ファイルにも自動的に挿入される<\/strong> 事となります。これらの内容に対して「設定を保存」機能を使用する場合、その点にご注意下さい。<\/p>\u000a\u000a<h4>名前を付けて保存ダイアログの挙動を選択可能に変更<\/h4>\u000a\u000a<p>CubePDF 1.0.0RC16 にて「名前を付けて保存」ダイアログの挙動を 1.0.0RC11 以前に戻しましたが、1.0.0RC18 では、どちらの挙動にするのかをユーザが選択可能な形に再修正しました。<\/p>\u000a\u000a<p>ただし、この設定は CubePDF メイン画面から行う事はできません。初期設定は CubePDF 1.0.0RC16 以降の挙動であるため、1.0.0RC12～RC15 時代の挙動に変更したい場合は、レジストリを以下のように編集して下さい。<\/p>\u000a\u000a<table>\u000a<thead>\u000a<tr>\u000a<th>名前<\/th>\u000a<th>内容<\/th>\u000a<\/tr>\u000a<\/thead>\u000a<tbody>\u000a<tr>\u000a<td>サブキー<\/td>\u000a<td>HKEY_CURRENT_USER\\Software\\CubeSoft\\CubePDF\\v2<\/td>\u000a<\/tr>\u000a<tr>\u000a<td>名前<\/td>\u000a<td>ExplicitDirectory<\/td>\u000a<\/tr>\u000a<tr>\u000a<td>種類<\/td>\u000a<td>REG_DWORD<\/td>\u000a<\/tr>\u000a<tr>\u000a<td>データ<\/td>\u000a<td>1<\/td>\u000a<\/tr>\u000a<\/tbody>\u000a<\/table>\u000a\u000a\u000a<h4>その他の修正<\/h4>\u000a\u000a<p>その他の修正として、CubePDF プリンタのインストール処理を改善しました。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/2019\/02\/15\/cubepdf-1.0.0rc18","PublishTime":"\/Date(1572412377000+0900)\/","Status":2,"Summary":"CubePDF 1.0.0RC18 をリリースしました。修正点は下記の通りです。 文書プロパティを「設定を保存」機能の対象となるように拡張 CubePDF には「設定の保存」機能が存在しますが、この機能の対象はこれまで「一般」および「その他」タブに存在する項目に限られていました。1.0.0RC18 では、これに加えて、「文書プロパティ」タブの各項目も設定の保存機能の対象となるように修正しました。 ","Title":"CubePDF 1.0.0RC18"},{"Categories":[],"Content":"<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\">CubePDF 1.0.0RC16<\/a> をリリースしました。修正点は下記の通りです。<\/p>\u000a\u000a<h4>名前を付けて保存ダイアログの挙動を修正<\/h4>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191030\/20191030140853.png\" alt=\"名前を付けてダイアログ\" \/><\/p>\u000a\u000a<p>CubePDF 1.0.0RC12 以降、出力ファイルに設定されているパスのフォルダ部分を「名前を付けて保存」ダイアログの初期表示フォルダとして指定していました。しかし、この挙動が使いづらくなったと言う指摘をいくつか頂いたため、CubePDF 1.0.0RC16 では、1.0.0RC11 以前と同様、初期表示フォルダ明示的に指定せず Windows に任せる形に修正しました。<\/p>\u000a\u000a<h4>インストーラの英語表示に対応<\/h4>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191030\/20191030140941.png\" alt=\"インストーラの英語表示\" \/><\/p>\u000a\u000a<p>CubePDF のメイン画面は CubePDF 1.0.0RC9 にて英語表示に対応しましたが、インストーラは日本語表示のままでした。1.0.0RC16 では、インストーラも含めて全て英語表示に対応しました。尚、インストーラに関しては、Windows の言語設定に応じて自動的に表示言語を切り替えるようになっています。<\/p>\u000a\u000a<h4>その他の修正<\/h4>\u000a\u000a<p>その他の修正は、下記の 2 点です。<\/p>\u000a\u000a<ul>\u000a<li>PDF に埋め込まれた画像に対して、CubePDF メイン画面で設定した解像度の値が反映されない不都合を修正しました。<\/li>\u000a<li>CubePDF のインストールおよびアンインストール処理を修正しました。特に、CubePDF プリンタのインストール処理に対して改善を図っています。<\/li>\u000a<\/ul>","Link":"https:\/\/clown.cube-soft.jp\/entry\/2018\/11\/22\/cubepdf-1.0.0rc16","PublishTime":"\/Date(1572412335000+0900)\/","Status":2,"Summary":"CubePDF 1.0.0RC16 をリリースしました。修正点は下記の通りです。 名前を付けて保存ダイアログの挙動を修正 CubePDF 1.0.0RC12 以降、出力ファイルに設定されているパスのフォルダ部分を「名前を付けて保存」ダイアログの初期表示フォルダとして指定していました。しかし、この挙動が使いづらくなったと言う指摘をいくつか頂いたため、CubePDF 1.0.0RC16 では、1.0.","Title":"CubePDF 1.0.0RC16"},{"Categories":[],"Content":"<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191026\/20191026230913.png\" alt=\"CubePDF の使用方法\" \/><\/a><\/p>\u000a\u000a<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\">CubePDF 1.0.0RC17<\/a> をリリースしました。修正点は下記の 3 点です。<\/p>\u000a\u000a<ul>\u000a<li>出力ファイル名の初期値が、特定の条件で文字化けする不都合を修正しました。<\/li>\u000a<li>インストール時の挙動を改善しました。<\/li>\u000a<li>Ghostscript 9.26 に更新しました。尚、9.26 ではセキュリティに関する修正が行われているようなので、可能な限り CubePDF のアップデートをお願いします（参考：<a href=\"https:\/\/www.ghostscript.com\/doc\/9.26\/News.htm\">Recent Changes in Ghostscript<\/a>）。<\/li>\u000a<\/ul>","Link":"https:\/\/clown.cube-soft.jp\/entry\/2018\/12\/04\/cubepdf-1.0.0rc17","PublishTime":"\/Date(1572412002000+0900)\/","Status":2,"Summary":"CubePDF 1.0.0RC17 をリリースしました。修正点は下記の 3 点です。 出力ファイル名の初期値が、特定の条件で文字化けする不都合を修正しました。 インストール時の挙動を改善しました。 Ghostscript 9.26 に更新しました。尚、9.26 ではセキュリティに関する修正が行われているようなので、可能な限り CubePDF のアップデートをお願いします（参考：Recent Cha","Title":"CubePDF 1.0.0RC17"},{"Categories":[],"Content":"<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191026\/20191026230913.png\" alt=\"CubePDF の使用方法\" \/><\/a><\/p>\u000a\u000a<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\">CubePDF 1.0.0RC19<\/a> をリリースしました。1.0.0RC19 では、CubePDF プリンタ（仮想プリンタ）のインストール処理に関する改善が行われました。CubePDF では 1.0.0RC16 以降、CubePDF プリンタのインストール処理のさらなる安定化を目標の一つとして更新を続けています。<\/p>\u000a\u000a<pre class=\"code\" data-lang=\"\" data-unlink>C:\\ProgramData\\CubeSoft\\CubePDF<\/pre>\u000a\u000a\u000a<p>もし、インストールの失敗や CubePDF プリンタが作成されなかった等の不都合がありましたら、上記のフォルダに存在するログファイルを添付して support@cube-soft.jp までお知らせ下さい。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/2019\/03\/14\/cubepdf-1.0.0rc19","PublishTime":"\/Date(1572099204000+0900)\/","Status":2,"Summary":"CubePDF 1.0.0RC19 をリリースしました。1.0.0RC19 では、CubePDF プリンタ（仮想プリンタ）のインストール処理に関する改善が行われました。CubePDF では 1.0.0RC16 以降、CubePDF プリンタのインストール処理のさらなる安定化を目標の一つとして更新を続けています。 C:\\ProgramData\\CubeSoft\\CubePDF もし、インストールの失","Title":"CubePDF 1.0.0RC19"},{"Categories":[],"Content":"<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\">CubePDF Utility 0.5.0β<\/a> をリリースしました。CubePDF Utility 0.5.0β では内部処理を大幅に刷新した事で、GUI による各種操作がよりスムーズになりました。また、起動時間の改善や、PDF ファイルによってはサムネイル画像が表示されないと言った不都合の報告をいくつか頂いていましたが、描画エンジンを PDFium に事で、これらの現象も改善しています。<\/p>\u000a\u000a<p>機能面では、メイン画面の英語表示に対応しました。Windows の表示言語設定によって自動的に表示モードが切り替わる他、ユーザが明示的に表示言語を選択する事も可能です。表示言語を変更したい場合は、CubePDF Utility メイン画面にある「その他」タブの「設定」ボタンを押し、表示される設定画面にて変更して下さい。<\/p>\u000a\u000a<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191025\/20191025200954.png\" alt=\"CubePDF Utility 英語表示モード\" \/><\/a><\/p>\u000a\u000a<p>尚、CubePDF Utility 0.5.0β より推奨環境を <a href=\"https:\/\/www.microsoft.com\/ja-JP\/download\/details.aspx?id=42643\">.NET Framework 4.5.2<\/a> 以降とします。.NET Framework 3.5 のみがインストールされている環境でも引き続き動作はしますが、できるだけ .NET Framework 4.5.2 以降がインストールされた環境でご利用頂くようお願いいたします。<\/p>\u000a\u000a<p>また、.NET Framework 3.5 のみがインストールされている環境と .NET Framework 4.5 以降がインストールされている環境ではインストールされる CubePDF Utility が異なりますので、.NET Framework 更新後は CubePDF Utility も再度インストールをお願いいたします。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/2018\/09\/26\/cubepdf-utility-0.5.0b","PublishTime":"\/Date(1572002082000+0900)\/","Status":1,"Summary":"CubePDF Utility 0.5.0β をリリースしました。CubePDF Utility 0.5.0β では内部処理を大幅に刷新した事で、GUI による各種操作がよりスムーズになりました。また、起動時間の改善や、PDF ファイルによってはサムネイル画像が表示されないと言った不都合の報告をいくつか頂いていましたが、描画エンジンを PDFium に事で、これらの現象も改善しています。 機能面で","Title":"CubePDF Utility 0.5.0β"},{"Categories":[],"Content":"<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\">CubePDF Utility 0.5.4β<\/a> をリリースしました。修正点は以下の通りです。<\/p>\u000a\u000a<h4>詳細を設定して抽出機能を追加<\/h4>\u000a\u000a<p>0.5.0β 以降、抽出機能に関しては「選択ページを抽出」のみに制限されていました。0.5.4β では、設定用画面を新たに設ける事により、抽出条件を柔軟に変更できるようにしました。メイン画面の「詳細を設定して抽出」メニューをクリックすると、下記のような画面が表示されます。<\/p>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191025\/20191025194957.png\" alt=\"詳細を設定して抽出画面\" \/><\/p>\u000a\u000a<p>出力ファイル形式として、PDF に加えて PNG 形式にも対応しました。尚、PNG の場合、出力される画像ファイルのサイズ（幅x高さ）を決定するために解像度を指定して下さい。例えば、A4 サイズの PDF ファイルを PNG ファイルとして抽出した場合、72dpi なら 595 x 847px、300dpi なら 2480 x 3508px の画像として保存されます。また、PNG ファイルの性質上「1 ページ毎に個別のファイルとして保存」オプションは無視されます（1 ページ 1 ファイルの形に強制）。<\/p>\u000a\u000a<h4>サムネイルおよびプレビュー画面の表示方法を改善<\/h4>\u000a\u000a<p>0.5.0β 以降、PDF ファイルによってはサムネイルおよびプレビュー画面の表示が不明瞭な現象が確認されていました。0.5.4β では、描画方法を見直す事により、これらの問題を改善しました。また、これまでは PDF に含まれる注釈の内容は表示されていませんでしたが、注釈の内容も含めて表示されるように修正しました。<\/p>\u000a\u000a<p>尚、現在 CubePDF Utility は PDF の描画用ライブラリとして PDFium を利用していますが、このライブラリを Google Chrome の現在の最新バージョンである Chromium 76 相当のものに更新しました。PDFium ライブラリをビルドする環境が整いましたので、今後は、Google Chrome の更新に合わせて CubePDF Utility で使用している PDFium (pdfium.dll) も自社で追随して更新していく予定です。<\/p>\u000a\u000a<h4>その他の修正<\/h4>\u000a\u000a<p>その他、メモリ消費量を改善しました。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/2019\/08\/02\/cubepdf-utility-0.5.4b","PublishTime":"\/Date(1572001567000+0900)\/","Status":2,"Summary":"CubePDF Utility 0.5.4β をリリースしました。修正点は以下の通りです。 詳細を設定して抽出機能を追加 0.5.0β 以降、抽出機能に関しては「選択ページを抽出」のみに制限されていました。0.5.4β では、設定用画面を新たに設ける事により、抽出条件を柔軟に変更できるようにしました。メイン画面の「詳細を設定して抽出」メニューをクリックすると、下記のような画面が表示されます。 出力","Title":"CubePDF Utility 0.5.4β"},{"Categories":[],"Content":"<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191024\/20191024192932.png\" alt=\"CubePDF Utility メイン画面\" \/><\/a><\/p>\u000a\u000a<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\">CubePDF Utility 0.5.1β<\/a> をリリースしました。修正点は以下の通りです。<\/p>\u000a\u000a<h4>0.4.1β から 0.5.0β の変更時に移行できていなかった機能を再実装<\/h4>\u000a\u000a<p>CubePDF Utility 0.5.0β では起動速度等の向上のために大幅な修正を行いましたが、この都合で一部の機能が 0.4.1β から移行できていませんでした。0.5.1β では、下記の機能について再実装しました。<\/p>\u000a\u000a<ul>\u000a<li>プロセス間（複数の CubePDF Utility 画面）を跨ぐドラッグ&amp;ドロップによる PDF ページの移動または挿入機能<\/li>\u000a<li>「詳細を設定して挿入」機能<\/li>\u000a<li>PNG, JPEG, BMP 画像を PDF ページとして挿入する機能（挿入するファイルとして選択可能）<\/li>\u000a<li>CubePDF Utility メイン画面の画面サイズ保持機能<\/li>\u000a<\/ul>\u000a\u000a\u000a<h4>パスワード保護された PDF ファイルの編集に関する不都合を修正<\/h4>\u000a\u000a<p>0.5.0β では、編集しようとした PDF ファイルが「既にパスワードによって保護されているが、閲覧用パスワードが設定されていない（ファイルを開く際にパスワードを求められない）」場合に編集できない不都合がありました。<\/p>\u000a\u000a<p>0.5.1β では、パスワードによって保護されている PDF ファイルを開こうとした時、常に「管理用パスワード (Owner password）」の入力を求めるように変更しました。ただし、内部処理の都合上、パスワードで保護されているかどうかが保存する直前まで判別できない PDF ファイルが存在します。この場合には、保存実行時に管理用パスワードの入力を求められます。<\/p>\u000a\u000a<h4>その他の修正<\/h4>\u000a\u000a<p>その他、CubePDF Utility メイン画面のスクロールバーをクリックした時に選択状況が解除される不都合を修正しました。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/2018\/10\/24\/cubepdf-utility-0.5.1b","PublishTime":"\/Date(1572001534000+0900)\/","Status":2,"Summary":"CubePDF Utility 0.5.1β をリリースしました。修正点は以下の通りです。 0.4.1β から 0.5.0β の変更時に移行できていなかった機能を再実装 CubePDF Utility 0.5.0β では起動速度等の向上のために大幅な修正を行いましたが、この都合で一部の機能が 0.4.1β から移行できていませんでした。0.5.1β では、下記の機能について再実装しました。 プロセ","Title":"CubePDF Utility 0.5.1β"},{"Categories":[],"Content":"<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191024\/20191024192932.png\" alt=\"CubePDF Utility メイン画面\" \/><\/a><\/p>\u000a\u000a<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\">CubePDF Utility 0.5.2β<\/a> をリリースしました。修正点は以下の通りです。<\/p>\u000a\u000a<ul>\u000a<li>32bit 版の CubePDF Utility で、パスワードで保護された PDF ファイルが開けない不都合を修正しました。<\/li>\u000a<li>プレビュー画面の表示処理を改善しました。<\/li>\u000a<li>高 DPI 設定時にサムネイルの表示が崩れる不都合を修正しました。<\/li>\u000a<li>ステータスバーに選択項目数が表示されない不都合を修正しました。<\/li>\u000a<li>Ctrl+Q でアプリケーションが終了するように修正しました（0.4.1β 互換）。<\/li>\u000a<li>最近使用した項目で表示しているアイコンを「ファイルに関連付けられたアイコン」を使用するように変更しました。<\/li>\u000a<\/ul>","Link":"https:\/\/clown.cube-soft.jp\/entry\/2018\/12\/10\/cubepdf-utility-0.5.2b","PublishTime":"\/Date(1572001308000+0900)\/","Status":2,"Summary":"CubePDF Utility 0.5.2β をリリースしました。修正点は以下の通りです。 32bit 版の CubePDF Utility で、パスワードで保護された PDF ファイルが開けない不都合を修正しました。 プレビュー画面の表示処理を改善しました。 高 DPI 設定時にサムネイルの表示が崩れる不都合を修正しました。 ステータスバーに選択項目数が表示されない不都合を修正しました。 Ctr","Title":"CubePDF Utility 0.5.2β"},{"Categories":[],"Content":"<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191024\/20191024192932.png\" alt=\"CubePDF Utility メイン画面\" \/><\/a><\/p>\u000a\u000a<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\">CubePDF Utility 0.5.3β<\/a> をリリースしました。修正点は以下の 2 点です。<\/p>\u000a\u000a<ul>\u000a<li>一部の環境で、関連付けられたアイコンの表示処理が原因でエラーとなる不都合を修正しました。<\/li>\u000a<li>Ctrl クリックで複数の項目を選択できない不都合を修正しました。<\/li>\u000a<\/ul>","Link":"https:\/\/clown.cube-soft.jp\/entry\/2019\/04\/16\/cubepdf-utility-0.5.3b","PublishTime":"\/Date(1572001139000+0900)\/","Status":2,"Summary":"CubePDF Utility 0.5.3β をリリースしました。修正点は以下の 2 点です。 一部の環境で、関連付けられたアイコンの表示処理が原因でエラーとなる不都合を修正しました。 Ctrl クリックで複数の項目を選択できない不都合を修正しました。","Title":"CubePDF Utility 0.5.3β"},{"Categories":[],"Content":"<p>現在、主に PDF ファイルを CubePDF 経由で再度 PDF に変換した場合、下図のように変換された PDF のテキストの色が赤くなる等の現象が確認されています。<\/p>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191024\/20191024183516.png\" alt=\"変換された PDF の色がおかしくなる現象について\" \/><\/p>\u000a\u000a<p>この現象への対応方法に関しては、現在検討中ですが、暫定的な回避策として Ghostscript 9.26 を利用するバージョンを公開しました。該当の現象が発生した場合、下記のインストーラを用いて再インストールを試して下さい。<\/p>\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/dl.php?ver=1.0.0-gs9.26&amp;mode=x86\">CubePDF 1.0.0, 32\/64bit 版 Windows 共用, Ghostscript 9.26<\/a><\/li>\u000a<li><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/dl.php?ver=1.0.0-gs9.26&amp;mode=x64\">CubePDF 1.0.0, 64bit 版 Windows 専用, Ghostscript 9.26<\/a><\/li>\u000a<\/ul>\u000a\u000a\u000a<p>また、PDF ファイルの結合やパスワードの設定等の PDF ファイルの編集を目的とする場合、<a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\">CubePDF Utility<\/a> や <a href=\"https:\/\/www.cube-soft.jp\/cubepdfpage\/\">CubePDF Page<\/a> の利用も併せてご検討をお願いします。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20190705\/cubepdf-color-problem","PublishTime":"\/Date(1571931322000+0900)\/","Status":1,"Summary":"現在、主に PDF ファイルを CubePDF 経由で再度 PDF に変換した場合、下図のように変換された PDF のテキストの色が赤くなる等の現象が確認されています。 この現象への対応方法に関しては、現在検討中ですが、暫定的な回避策として Ghostscript 9.26 を利用するバージョンを公開しました。該当の現象が発生した場合、下記のインストーラを用いて再インストールを試して下さい。 Cu","Title":"変換された PDF の色がおかしくなる現象について"},{"Categories":[],"Content":"<p>本日、CubePDF 1.0.0 を <strong>最初の正式版<\/strong> としてリリースしました。この記事では、1.0.0 までの道のりの回顧と、同時リリースした有償によるカスタム仮想プリンタ CubePDF Customize の宣伝、もとい、狙いについて記載します。<\/p>\u000a\u000a<ul class=\"table-of-contents\">\u000a    <li><a href=\"#CubePDF-100-のリリースまでの道のり\">CubePDF 1.0.0 のリリースまでの道のり<\/a><ul>\u000a            <li><a href=\"#CubePDF-の開発に対するモチベーション\">CubePDF の開発に対するモチベーション<\/a><\/li>\u000a        <\/ul>\u000a    <\/li>\u000a    <li><a href=\"#有償版カスタム仮想プリンタ-CubePDF-Customize-の提供開始\">有償版カスタム仮想プリンタ CubePDF Customize の提供開始<\/a><\/li>\u000a<\/ul>\u000a\u000a<h4 id=\"CubePDF-100-のリリースまでの道のり\">CubePDF 1.0.0 のリリースまでの道のり<\/h4>\u000a\u000a<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20190621\/20190621141128.png\" alt=\"CubePDF メイン画面\" \/><\/a><\/p>\u000a\u000a<p>CubePDF 1.0.0 の修正点は下記の通りです。<\/p>\u000a\u000a<ul>\u000a<li>Ghostscript 9.27 のバージョンアップに対応しました。<\/li>\u000a<li>Ghostscript エラー (-100) が発生する現象を改善しました。<\/li>\u000a<li>CubePDF インストール時、登録されているプリンタ数がゼロの時に発生する不都合を修正しました。<\/li>\u000a<\/ul>\u000a\u000a\u000a<p>CubePDF は 2010 年 7 月 7 日に初版である 0.9.0 β をリリースして、その歴史が始まりました。そこから既に 9 年の月日が経過しており、1.0.0RC1 から数えても 6 年半位となっています。Web 上で「いつまで RC なんだよ」との評判をちらほら見かける事もあり、私としても「それな」とは思っていまいた。<\/p>\u000a\u000a<p>CubePDF は最初期の頃、仮想プリンタを実現するためのシステムライブラリとして <a href=\"http:\/\/www.ghostgum.com.au\/software\/redmon.htm\">RedMon<\/a> を利用していましたが、いくつかの課題が浮上した結果、最終的に自前のものに換装と言う選択をしました。この時にリリースされたバージョンが 1.0.0RC1 であり、当初の予定では、しばらく様子を見た後に 1.0.0 正式版とするつもりでした。しかし、様子を見ている内に様々な問題が発覚あるいは新たに出現し、それらの対策を検討している内に機を逸して現在に至っています。<\/p>\u000a\u000a<p>参考までに、RC のバージョン毎の主な課題は下記のような感じでした。この内、フォント埋め込み問題に関しては、残念ながら現在においても根本的な解決方法は見つかっておらず、いったん機能自体を取り下げると言う形になっています。<\/p>\u000a\u000a<ul>\u000a<li>PDF へのフォント非埋め込み設定時の文字化け (RC1 ～ RC5)<\/li>\u000a<li>Microsoft ストアアプリ (UWP) への対応 (RC8 ～ RC11)<\/li>\u000a<li><a href=\"https:\/\/clown.hatenablog.jp\/entry\/20180928\/cubepdf\">内部コードの大幅なリファクタリング<\/a> (RC12)<\/li>\u000a<li>Ghostscript で発生した脆弱性への対応 (RC13 ～ RC15)<\/li>\u000a<li>仮想プリンタのインストール処理の改善および汎用化 (RC16 ～ RC19)<\/li>\u000a<\/ul>\u000a\u000a\u000a<h5 id=\"CubePDF-の開発に対するモチベーション\">CubePDF の開発に対するモチベーション<\/h5>\u000a\u000a<p>また、別の理由として、私自身の CubePDF の開発に対するモチベーションが一時期低下していた事も挙げられます。 2015 年に Windows 10 がリリースされましたが、この時に「Microsoft Print To PDF」と言う機能が Windows 10 の標準機能として盛り込まれました。これは PDF に変換する機能を仮想プリンタとして実現しているものだったので、「あれ？これもう CubePDF 要らなくない？」と言うのが率直な感想でした。<\/p>\u000a\u000a<p>モチベーションを取り戻したのは、CubePDF 1.0.0RC12 をリリースした頃となります。一つは、Microsoft Print To PDF を調査していると、どうもプリンタドライバの処理として埋め込み画像に対して JPEG 圧縮を実施しているようで、これを回避するのは困難ではないか？（標準機能に対する優位性があるのではないか？）と言う感触を得たのがきっかけとなりました。また、現実の現象として Windows 10 のリリース後も CubePDF のダウンロード数は減少しておらず、このまま終わらすべきではないと言う意識に変わった事も大きかったと思います。<\/p>\u000a\u000a<p>そのような紆余曲折がありましたが、ここ 2 年位の試行錯誤により、個人的にも「不都合はもうない……なんて事を言えるはずはないが、内部コードも開発当初に比べてかなり整理され、ユニットテストの力を借りる事によってデグレードを引き起こす可能性もかなり低減された」と思える程度には改善されてきたため、今回「正式版」を名乗る事を決断しました。<\/p>\u000a\u000a<p><a href=\"https:\/\/codecov.io\/gh\/cube-soft\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20181230\/20181230004952.png\" alt=\"CI サービス上でのテスト結果の様子\" \/><\/a><\/p>\u000a\u000a<h4 id=\"有償版カスタム仮想プリンタ-CubePDF-Customize-の提供開始\">有償版カスタム仮想プリンタ CubePDF Customize の提供開始<\/h4>\u000a\u000a<p><a href=\"https:\/\/www.cube-soft.jp\/cubevp\/\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191024\/20191024182309.png\" alt=\"CubePDF と CubePDF Customize の比較図\" \/><\/a><\/p>\u000a\u000a<p>今回のもう一つの大きな発表は、CubePDF で使用している仮想プリンタ部分のみを有償で提供する CubePDF Customize です。概要に関しては、<a href=\"https:\/\/www.cube-soft.jp\/cubevp\/\">CubePDF Customize の Web ページ<\/a> を参照して頂くとして、ここでは CubePDF Customize の提供開始に至った個人的な思いについて記載します。<\/p>\u000a\u000a<p>キューブ・ソフトでは、提供しているソフトウェアの多くのソースコードを <a href=\"https:\/\/github.com\/cube-soft\">cube-soft - GitHub<\/a> にて公開しています。公開を決めた会社としてのきっかけは、CubePDF が Ghostscript 等のライブラリを利用している事によるものだったのですが、それとは別に <strong>自分の書いたコードが公開できる<\/strong> と言う事が私自身にとって非常に強いモチベーションとして機能しています。しかし、（GPL ではない）ソースコードを公開する <strong>会社として<\/strong> のモチベーションが弱い事は長年気になっていた部分であり、もう少し公開する事の意義を持たせたいとも感じていました。<\/p>\u000a\u000a<p>この問題への打開策を模索していた時に、非常に参考となった記事がありました。<\/p>\u000a\u000a<blockquote><p>カスタマイズをするのはかなりしんどい。自社ではカスタマイズは受け付けていない。もし機能追加をする場合はオープンソースでの公開が前提となる。そのため「カスタマイズのサポート」を Sora を購入している顧客に対してのみ有償にて提供している。<\/p>\u000a\u000a<p>（中略）<\/p>\u000a\u000a<p>つまり、この製品のビジネスモデルこうだ。<\/p>\u000a\u000a<ul>\u000a<li>カスタマイズを提供せずカスタマイズのテクニカルサポートを提供する<\/li>\u000a<li>カスタマイズはせずオープンソースとして公開する<\/li>\u000a<li>WebRTC SFU Sora を購入してもらっている顧客へのみ提供する<\/li>\u000a<\/ul>\u000a\u000a\u000a<p>リアルタイムな音声や映像をバイナリ一つで配信できるのはとても便利だ。ただ、それを特定のハードに対応させる場合はカスタマイズが必要になる。さらにもともとリアルタイム配信の世界は難しい。<\/p>\u000a\u000a<p>１から自分たちだけでカスタマイズするよりも、そもそも Momo を開発をしている会社と一緒にやっていったほうがいい。<\/p>\u000a\u000a<p><a href=\"https:\/\/medium.com\/@voluntas\/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%BA%E3%83%89%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%A8%E3%82%AA%E3%83%BC%E3%83%97%E3%83%B3%E3%82%BD%E3%83%BC%E3%82%B9-a67f33f7a083\">クローズドソースとオープンソース – V – Medium<\/a><\/p><\/blockquote>\u000a\u000a<p>時雨堂の <a href=\"https:\/\/medium.com\/@voluntas\">@voluntas<\/a> さんの記事は、自分が開発を続ける、あるいは組織を継続させていく上で参考になるものが多く、よく読ませて頂いています。そして、自社ソフトウェアの <strong>クローズドソースとオープンソースの境界<\/strong> を明確に認識できたきっかけとなったのが上記でした。<\/p>\u000a\u000a<p>CubePDF は、以下の 3 種類の機能に大別されます。<\/p>\u000a\u000a<ol>\u000a<li>仮想プリンタを構築するためのシステムライブラリ<\/li>\u000a<li>仮想プリンタから渡されたデータを PDF 等に変換するためのアプリケーション<\/li>\u000a<li>これらの機能を連携させ、端末にインストールするためのアプリケーション<\/li>\u000a<\/ol>\u000a\u000a\u000a<p>この内、2. の機能を完全に取り除き、1. と 3. のみを有償にて提供するのが CubePDF Customize となります。そして、2. の部分を <strong>ユーザ自身の手によって実装してもらう<\/strong> ために積極的に技術情報を公開していくのが、今回の大きな挑戦です。<\/p>\u000a\u000a<p>CubePDF Customize に関する技術情報は、<a href=\"https:\/\/github.com\/cube-soft\/Cube.Vp.Docs\">Cube.Vp.Docs<\/a> を随時更新していく事により公開を続けます。また、この技術的サポートの一環として、CubePDF 1.0.0 では、CubePDF のメイン処理に当たる部分のみを抽出し NuGet パッケージとして公開する事も開始しました（<a href=\"https:\/\/www.nuget.org\/packages\/Cube.Pdf.Converter\">Cube.Pdf.Converter<\/a>)。例えば、CubePDF と同等の変換処理を行う最も簡単なサンプルコードは下記となります。<\/p>\u000a\u000a<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink><span class=\"synComment\">\/\/ using Cube.Pdf.Converter;<\/span>\u000a<span class=\"synComment\">\/\/ using System.Reflection;<\/span>\u000a\u000a<span class=\"synType\">static<\/span> <span class=\"synType\">void<\/span> Main(<span class=\"synType\">string<\/span>[] args)\u000a{\u000a    var settings = <span class=\"synStatement\">new<\/span> SettingFolder(Assembly.GetExecutingAssembly());\u000a    settings.Load();    <span class=\"synComment\">\/\/ レジストリの設定をロード<\/span>\u000a    settings.Set(args); <span class=\"synComment\">\/\/ 仮想プリンタからの引数を解析<\/span>\u000a\u000a    <span class=\"synStatement\">using<\/span> (var facade = <span class=\"synStatement\">new<\/span> Facade(settings)) facade.Invoke();\u000a}\u000a<\/pre>\u000a\u000a\u000a<p>CubePDF Customize の概要を知るための最初のステップとしては <a href=\"https:\/\/github.com\/cube-soft\/Cube.Vp.Docs\/blob\/master\/Documents\/Cube.Vp.Tutorial.ja.md\">Tutorial - Cube.Vp.Docs - GitHub<\/a> を参照下さい。また、Cube.Pdf.Converter ライブラリに関しては、<a href=\"https:\/\/github.com\/cube-soft\/Cube.Vp.Docs\/blob\/master\/Documents\/Cube.Pdf.Converter.ja.md\">Cube.Pdf.Converter - Cube.Vp.Docs - GitHub<\/a> に概要を記載しています。<\/p>\u000a\u000a<p>仮想プリンタとして CubePDF が知名度を得ていくにつれて、ありがたい事に、これまで数多くのカスタマイズのご依頼を頂いてきました。しかし、それらの中には、金銭的、あるいは時間的な面で「本来であれば、アプリケーション部分は貴社の方で実装してもらった方が絶対良いはずなのだが……」と感じる事が多々あったのも事実です。今回の CubePDF Customize によって、私（弊社）とユーザの皆様、双方にとって良い形に向かえるようになる事を期待して、これからも開発を続けていきたいと思います。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20190621\/cubepdf-and-cubevp","PublishTime":"\/Date(1571926552000+0900)\/","Status":1,"Summary":"本日、CubePDF 1.0.0 を 最初の正式版 としてリリースしました。この記事では、1.0.0 までの道のりの回顧と、同時リリースした有償によるカスタム仮想プリンタ CubePDF Customize の宣伝、もとい、狙いについて記載します。 CubePDF 1.0.0 のリリースまでの道のり CubePDF の開発に対するモチベーション 有償版カスタム仮想プリンタ CubePDF Cust","Title":"CubePDF 正式版とカスタム仮想プリンタの公開"},{"Categories":[],"Content":"<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191024\/20191024192932.png\" alt=\"CubePDF Utility メイン画面\" \/><\/a><\/p>\u000a\u000a<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\">CubePDF Utility 0.5.5β<\/a> をリリースしました。修正点は以下の 2 点です。<\/p>\u000a\u000a<ul>\u000a<li>一部のページを別の PDF ファイルとして抽出する時、場合によって抽出後のページ順序がおかしくなる不都合を修正しました。<\/li>\u000a<li>PDFium を Google Chrome 77 相当に更新しました（<a href=\"https:\/\/www.nuget.org\/packages\/Cube.Native.Pdfium.Lite\/1.0.3865.1\">Cube.Native.Pdfium.Lite 1.0.3865.1<\/a>）。<\/li>\u000a<\/ul>\u000a\u000a\u000a<p>尚、<a href=\"https:\/\/clown.cube-soft.jp\/entry\/20190805\/cubepdf-password\">CubePDF シリーズと PDF のパスワード保護について<\/a> で触れましたが、CubePDF Utility に関しては現在、閲覧機能を強化するための修正を進めています。この修正にはもう少し時間を要する事となりそうですので、それまでの間は PDFium の更新に追随する程度に留まる予定となっています。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20191024\/cubepdf-utility-0.5.5b","PublishTime":"\/Date(1571912999000+0900)\/","Status":1,"Summary":"CubePDF Utility 0.5.5β をリリースしました。修正点は以下の 2 点です。 一部のページを別の PDF ファイルとして抽出する時、場合によって抽出後のページ順序がおかしくなる不都合を修正しました。 PDFium を Google Chrome 77 相当に更新しました（Cube.Native.Pdfium.Lite 1.0.3865.1）。 尚、CubePDF シリーズと PD","Title":"CubePDF Utility 0.5.5β"},{"Categories":[],"Content":"<p>本日、CubeICE 0.9.0 β をリリースしました。修正内容は <a href=\"https:\/\/blog.cube-soft.jp\/?p=1687\">リリースノート<\/a> に任せるとして、この記事では CubeICE で利用している <a href=\"https:\/\/www.7-zip.org\/\">7-Zip<\/a> のカスタマイズ版ライブラリの概要と、7-Zip ライブラリのみを更新する方法について記述します。<\/p>\u000a\u000a<ul class=\"table-of-contents\">\u000a    <li><a href=\"#概要\">概要<\/a><\/li>\u000a    <li><a href=\"#手動による更新方法\">手動による更新方法<\/a><\/li>\u000a<\/ul>\u000a\u000a<h4 id=\"概要\">概要<\/h4>\u000a\u000a<p>CubeICE は、実際の圧縮・解凍処理を全て 7-Zip に頼った実装となっていますが、オリジナルの 7-Zip ライブラリ (7z.dll) に対して文字コードの推測処理を追加し、Unicode 文字セット<a href=\"#f-d91cf88d\" name=\"fn-d91cf88d\" title=\"Visual C++ の設定には、Unicode 文字セットでビルドする方法とマルチバイト文字セットでビルドする方法の 2 種類が提供されています。\">*1<\/a> でビルドするようにカスタマイズしています。このカスタマイズ版 7-Zip のソースコードおよびビルド結果は <a href=\"https:\/\/github.com\/cube-soft\/7z\">cube-soft\/7z - GitHub<\/a> より取得する事ができます。<\/p>\u000a\u000a<p>今回、この記事を執筆しようと思った理由は、CubeICE のバージョンアップが間に合わない時のために、7-Zip だけでも更新できる方法を公開しておいた方が良いと思ったためでした。先日、<a href=\"https:\/\/forest.watch.impress.co.jp\/docs\/news\/1120644.html\">「7-Zip」に任意コード実行の脆弱性、修正版の v18.05 が公開<\/a> と言う記事で報道された通り、2018\/04\/30 に公開された 7-Zip 18.05 には脆弱性に対する修正も含まれていましたが、諸々の都合で 7-Zip の該当バージョンを適用した CubeICE がリリースされるまでに 3 週間強のタイムラグが発生する事となりました。<\/p>\u000a\u000a<p>カスタマイズ版 7-Zip のオリジナル版への追随に関しては、<a href=\"https:\/\/clown.hatenablog.jp\/entry\/cubeice\">圧縮・解凍ソフト CubeICE をゼロから改修<\/a> した段階で楽に実現できるように改善されたため、多くの場合で、CubeICE のバージョンアップのかなり前の段階で利用可能な状態となります。そのため、7-Zip 由来の脆弱性等に関しては、これらのライブラリを差し換える事で CubeICE のバージョンアップ前であっても対応する事ができます。<\/p>\u000a\u000a<h4 id=\"手動による更新方法\">手動による更新方法<\/h4>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20190118\/20190118172249.png\" alt=\"CubeICE のバージョン確認\" \/><\/p>\u000a\u000a<p>まず、CubeICE のバージョンを確認して下さい。CubeICE のバージョンは「CubeICE 設定」の「バージョン情報」タブで確認する事ができます。この時、<strong>バージョンが 0.8.0β 未満<\/strong>（0.7.3β や 0.6.8β など）の場合は CubeICE を最新版にアップデートして下さい。CubeICE は 0.8.0β にて大幅な変更が加えられていますので、それ以前のバージョンには適応できない可能性があります。バージョンが問題なければ、その右隣に記述されている文字列（<strong>x86 または x64<\/strong>）を覚えておいて下さい。<\/p>\u000a\u000a<p>次に、 <a href=\"https:\/\/github.com\/cube-soft\/7z\/releases\">Releases - cube-soft\/7z - GitHub<\/a> へ移動します。ここで、先ほどのバージョン表示画面で確認した x86\/x64 に対応する Zip ファイルをダウンロードして下さい。ダウンロード終了後、解凍したフォルダにある 7z.dll と 7z.sfx のファイルを CubeICE のインストールフォルダ（初期設定では C:\\Program Files\\CubeICE）にコピーして差し換えると、手動による 7-Zip の更新作業は完了です。<\/p>\u000a<div class=\"footnote\">\u000a<p class=\"footnote\"><a href=\"#fn-d91cf88d\" name=\"f-d91cf88d\" class=\"footnote-number\">*1<\/a><span class=\"footnote-delimiter\">:<\/span><span class=\"footnote-text\">Visual C++ の設定には、Unicode 文字セットでビルドする方法とマルチバイト文字セットでビルドする方法の 2 種類が提供されています。<\/span><\/p>\u000a<\/div>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20180524\/cubeice-and-7zip","PublishTime":"\/Date(1571912426000+0900)\/","Status":1,"Summary":"本日、CubeICE 0.9.0 β をリリースしました。修正内容は リリースノート に任せるとして、この記事では CubeICE で利用している 7-Zip のカスタマイズ版ライブラリの概要と、7-Zip ライブラリのみを更新する方法について記述します。 概要 手動による更新方法 概要 CubeICE は、実際の圧縮・解凍処理を全て 7-Zip に頼った実装となっていますが、オリジナルの 7-Z","Title":"CubeICE に含まれる 7-Zip を手動で更新する方法"},{"Categories":[],"Content":"<p>先ほど「Zip Slip」と命名された圧縮・解凍処理に関する脆弱性の情報を目にしました。<\/p>\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/snyk.io\/research\/zip-slip-vulnerability\">Zip Slip Vulnerability<\/a><\/li>\u000a<li><a href=\"http:\/\/www.itmedia.co.jp\/enterprise\/articles\/1806\/06\/news061.html\">アーカイブファイル関連の脆弱性「Zip Slip」、大手プロジェクト多数に影響<\/a><\/li>\u000a<li><a href=\"https:\/\/forest.watch.impress.co.jp\/docs\/news\/1126064.html\">広く採用されている書庫展開処理に任意コード実行を許す脆弱性<\/a><\/li>\u000a<\/ul>\u000a\u000a\u000a<p>この記事では、Zip Slip の概要および <a href=\"https:\/\/www.cube-soft.jp\/cubeice\/\">CubeICE<\/a> における関連部分の処理内容について記載します。尚、<strong>CubeICE に関しては、少なくとも 0.8.0β 以降であれば、Zip Slip 脆弱性の原因とされる不都合はない<\/strong> 事を <a href=\"https:\/\/snyk.io\/\">Snyk<\/a> によって公開されている <a href=\"https:\/\/github.com\/snyk\/zip-slip-vulnerability\">サンプルファイル<\/a> を利用したテスト等によって確認しています。テストコードは <a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem.SevenZip\/blob\/master\/Libraries\/Tests\/Sources\/ArchiveReaderTest.cs\">ArchiveReaderTest<\/a> を参照下さい。また、これに合わせて、CubeICE 0.8.0β 未満をご利用のユーザは、可能な限り最新版のご利用をお願いします（参考：<a href=\"https:\/\/clown.hatenablog.jp\/entry\/cubeice\">圧縮・解凍ソフト CubeICE をゼロから改修<\/a>）。<\/p>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20180606\/20180606153556.png\" alt=\"Zip Slip 確認用のサンプルファイルを CubeICE で解凍した結果\" \/><\/p>\u000a\u000a<ul class=\"table-of-contents\">\u000a    <li><a href=\"#Zip-Slip-脆弱性の概要\">Zip Slip 脆弱性の概要<\/a><\/li>\u000a    <li><a href=\"#CubeICE-における圧縮ファイル中のパスの扱い\">CubeICE における圧縮ファイル中のパスの扱い<\/a><\/li>\u000a<\/ul>\u000a\u000a<h4 id=\"Zip-Slip-脆弱性の概要\">Zip Slip 脆弱性の概要<\/h4>\u000a\u000a<p>Zip Slip は、圧縮ファイルのファイルリスト（ヘッダ部分）に \"..\" (double-dot) を含むパスが存在する場合、親ディレクトリに存在するファイルがユーザの意図しない形でコピーまたは上書きされる <a href=\"https:\/\/ja.wikipedia.org\/wiki\/%E3%83%87%E3%82%A3%E3%83%AC%E3%82%AF%E3%83%88%E3%83%AA%E3%83%88%E3%83%A9%E3%83%90%E3%83%BC%E3%82%B5%E3%83%AB\">directory traversal<\/a> と呼ばれる脆弱性の一種のようです。例えば、Zip Slip の解説サイトでは tmp\/evil.sh と言うパスの前に大量の \"..\" を付記しておく事で、\/tmp ディレクトリに悪意のあるファイルを作成する手順が示されています。<\/p>\u000a\u000a<blockquote><p>In the example below, we can see the contents of a zip file. It has two files, a good.sh file which would be extracted into the target directory and an evil.sh file which is trying to traverse up the directory tree to hit the root and then add a file into the tmp directory. When you attempt to cd .. in the root directory, you still find yourself in the root directory, so a malicious path could contain many levels of ..\/ to stand a better chance of reaching the root directory, before trying to traverse to sensitive files.\u000a<pre class=\"code\">5 Tue Jun 5 11:04:29 BST 2018 good.sh\u000a20 Tue Jun 5 11:04:42 BST 2018 ..\/..\/..\/..\/..\/..\/..\/..\/tmp\/evil.sh<\/pre><\/p>\u000a\u000a<p><a href=\"https:\/\/snyk.io\/research\/zip-slip-vulnerability\">Zip Slip Vulnerability<\/a><\/p><\/blockquote>\u000a\u000a<p>圧縮ファイルのファイルリストに含まれる \"..\" を処理する際には注意が必要である、と言う問題自体は古くから認識されています。例えば、先日 iOS や Android 上の多数のアプリに「ZipperDown」と命名された脆弱性が存在すると報道されましたが、これも directory traversal に起因するものだったようです。<\/p>\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/zipperdown.org\/\">ZipperDown<\/a><\/li>\u000a<li><a href=\"https:\/\/vulners.com\/myhack58\/MYHACK58:62201890308\">ZipperDown vulnerability, hype or imminent-vulnerability warning-the black bar safety net<\/a><\/li>\u000a<\/ul>\u000a\u000a\u000a<p>しかし、今回の脆弱性に関しても、ファイルリストに含まれるパスをそのまま扱っている事例が思いの外多かったのか <a href=\"https:\/\/github.com\/snyk\/zip-slip-vulnerability#affected-libraries\">Zip Slip の影響を受けるライブラリ<\/a> もかなりの数に上っています。Snyk では、例えば下記のように、ライブラリから取得出来た名前（相対パス）をそのまま結合するようなコードが含まれている場合、特に注意を要する旨が記載されています。<\/p>\u000a\u000a<pre class=\"code lang-java\" data-lang=\"java\" data-unlink>Enumeration&lt;ZipEntry&gt; entries = zip.getEntries();\u000a<span class=\"synStatement\">while<\/span> (entries.hasMoreElements()) {\u000a    ZipEntry e = entries.nextElement();\u000a    File f = <span class=\"synStatement\">new<\/span> File(destinationDir, e.getName());\u000a    InputStream input = zip.getInputStream(e);\u000a    IOUtils.copy(input, write(f));\u000a}\u000a<\/pre>\u000a\u000a\u000a<h4 id=\"CubeICE-における圧縮ファイル中のパスの扱い\">CubeICE における圧縮ファイル中のパスの扱い<\/h4>\u000a\u000a<p>CubeICE では、圧縮ファイルのヘッダ情報から取得したパスに対して <a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem\/blob\/master\/Libraries\/PathFilter.cs\">PathFilter<\/a> と言う自作クラスを介してアクセスしています。PathFilter は、指定されたパスをディレクトリ単位で分割し、それぞれのファイル名またはディレクトリ名に対して下記のようなチェックを実行します。また、CubeICE では 圧縮・解凍時に特定のファイルまたはディレクトリをフィルタリングする機能を提供していますので、その判定も PathFilter が担っています。<\/p>\u000a\u000a<ul>\u000a<li>カレントディレクトリを表す \".\" (single-dot) が含まれているかどうか<\/li>\u000a<li>親ディレクトリを表す \"..\" (double-dot) が含まれているかどうか<\/li>\u000a<li>ドライブ文字 (drive-letter) が含まれているかどうか<\/li>\u000a<li>UNC パスを表す接頭辞 \"\\\\\" が含まれているかどうか<\/li>\u000a<li>サービス機能の不活性化を表す接頭辞 \"\\\\?\\\" が含まれているかどうか<\/li>\u000a<li>ファイル名またはディレクトリ名の一部に使用不可能な記号が含まれているかどうか<\/li>\u000a<li>ファイル名またはディレクトリ名に Windows で予約済みの名前が存在するかどうか<\/li>\u000a<\/ul>\u000a\u000a\u000a<p>この PathFilter を実際に利用しているコードが下記 (<a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem.SevenZip\/blob\/master\/Libraries\/Core\/Sources\/Details\/ArchiveItemController.cs\">ArchiveItemController<\/a>) になります。ただし、これは圧縮ファイルの 1 項目を表す <a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem.SevenZip\/Sources\/blob\/master\/Core\/Libraries\/ArchiveItem.cs\">ArchiveItem<\/a> クラスの内部実装なので、普段はその存在を意識する事はありません。<\/p>\u000a\u000a<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink>_filter = <span class=\"synStatement\">new<\/span> PathFilter(RawName)\u000a{\u000a    AllowParentDirectory  = <span class=\"synConstant\">false<\/span>,\u000a    AllowDriveLetter      = <span class=\"synConstant\">false<\/span>,\u000a    AllowCurrentDirectory = <span class=\"synConstant\">false<\/span>,\u000a    AllowInactivation     = <span class=\"synConstant\">false<\/span>,\u000a    AllowUnc              = <span class=\"synConstant\">false<\/span>,\u000a};\u000a\u000asrc.FullName = _filter.Result;\u000a<\/pre>\u000a\u000a\u000a<p>上記の各種 AllowXxx プロパティでは、対応するシンボル（single-dot, double-dot, drive-letter, ...) の存在を許容するかどうかを設定しています。PathFilter は許容しない場合には該当のシンボルを除去するため、結果として CubeICE ではこれらの特殊なシンボルを全て無視します。例えば、脆弱性の解説において例示されていた \"..\/..\/..\/..\/..\/..\/..\/..\/tmp\/evil.sh\" と言うパスは、単に \"tmp\/evil.sh\" として扱います。この処理は、基本となるライブラリ部分で強制的に実行しているため、<a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem.SevenZip\/blob\/master\/Readme.md\">Readme<\/a> に記載している下記のサンプルコードにおいても、今回の脆弱性の影響を受ける事はありません。<\/p>\u000a\u000a<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink><span class=\"synComment\">\/\/ Set password directly or using Query&lt;string&gt;<\/span>\u000avar password = <span class=\"synStatement\">new<\/span> Cube.Query&lt;<span class=\"synType\">string<\/span>&gt;(e =&gt; e.Result = <span class=\"synConstant\">&quot;password&quot;<\/span>);\u000a<span class=\"synStatement\">using<\/span> (var reader = <span class=\"synStatement\">new<\/span> ArchiveReader(<span class=\"synSpecial\">@<\/span><span class=\"synConstant\">&quot;path\\to\\archive&quot;<\/span>, password))\u000a{\u000a    reader.Extract(<span class=\"synSpecial\">@<\/span><span class=\"synConstant\">&quot;path\\to\\directory&quot;<\/span>);\u000a}\u000a<\/pre>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20180606\/zip-slip-and-cubeice","PublishTime":"\/Date(1571912414000+0900)\/","Status":1,"Summary":"先ほど「Zip Slip」と命名された圧縮・解凍処理に関する脆弱性の情報を目にしました。 Zip Slip Vulnerability アーカイブファイル関連の脆弱性「Zip Slip」、大手プロジェクト多数に影響 広く採用されている書庫展開処理に任意コード実行を許す脆弱性 この記事では、Zip Slip の概要および CubeICE における関連部分の処理内容について記載します。尚、CubeIC","Title":"CubeICE の Zip Slip 脆弱性に関する調査報告"},{"Categories":[],"Content":"<p><a href=\"https:\/\/clown.hatenablog.jp\/entry\/cubeice\">圧縮・解凍ソフト CubeICE をゼロから改修<\/a> に記載した通り、昨年、<a href=\"https:\/\/www.cube-soft.jp\/cubeice\/\">CubeICE<\/a> に対して大幅な修正を実施しましたが、この際にライブラリとしても利用できるようにインターフェース（クラスやメソッド）を整理する事をテーマの一つに設定していました。そこで、この記事では CubeICE （正確には Cube.FileSystem.SevenZip.dll）を 7-Zip ライブラリとして利用するための方法について記載します。<\/p>\u000a\u000a<ul class=\"table-of-contents\">\u000a    <li><a href=\"#事前準備\">事前準備<\/a><\/li>\u000a    <li><a href=\"#圧縮ファイルの解凍展開\">圧縮ファイルの解凍・展開<\/a><\/li>\u000a    <li><a href=\"#圧縮ファイルの生成\">圧縮ファイルの生成<\/a><\/li>\u000a    <li><a href=\"#進捗状況のレポート機能\">進捗状況のレポート機能<\/a><\/li>\u000a<\/ul>\u000a\u000a<h4 id=\"事前準備\">事前準備<\/h4>\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/www.nuget.org\/packages\/Cube.FileSystem.SevenZip\">Cube.FileSystem.SevenZip - NuGet<\/a><\/li>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem.SevenZip\">Cube.FileSystem.SevenZip - GitHub<\/a><\/li>\u000a<\/ul>\u000a\u000a\u000a<p>Cube.FileSystem.SevenZip は <a href=\"https:\/\/www.nuget.org\/packages\/Cube.FileSystem.SevenZip\">NuGet<\/a> 経由で取得する事ができますが、この中には 7z.dll が含まれないので別途ダウンロードして実行ディレクトリに配置して下さい。7z.dll は <a href=\"https:\/\/www.7-zip.org\/\">www.7-zip.org<\/a> から取得できる他、オリジナルに対して Unicode ビルドする等いくつかの修正を加えたものを <a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem.SevenZip\/releases\">GitHub releases<\/a> に公開しています（また、修正版のリポジトリは <a href=\"https:\/\/github.com\/cube-soft\/7z\">cube-soft\/7z<\/a> で公開しています）。尚、C# 等から Unmanaged な dll を利用する場合 x86\/x64 の設定が問題になるので、特に Any CPU でビルドする場合、どちらの dll を必要とするか注意して下さい。<\/p>\u000a\u000a<h4 id=\"圧縮ファイルの解凍展開\">圧縮ファイルの解凍・展開<\/h4>\u000a\u000a<p>圧縮ファイルを解凍・展開するサンプルコードは下記になります。尚、全てのコードで \"using Cube.FileSystem.SeventZip;\" が記述されているものとします。<\/p>\u000a\u000a<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink><span class=\"synComment\">\/\/ Set password directly or using Query&lt;string&gt;<\/span>\u000avar password = <span class=\"synStatement\">new<\/span> Cube.Query&lt;<span class=\"synType\">string<\/span>&gt;(e =&gt;\u000a{\u000a    e.Result = <span class=\"synConstant\">&quot;password&quot;<\/span>;\u000a    e.Cancel = <span class=\"synConstant\">false<\/span>;\u000a});\u000a\u000a<span class=\"synStatement\">using<\/span> (var reader = <span class=\"synStatement\">new<\/span> ArchiveReader(<span class=\"synSpecial\">@<\/span><span class=\"synConstant\">&quot;path\\to\\archive&quot;<\/span>, password))\u000a{\u000a    var progress = <span class=\"synStatement\">new<\/span> Progress&lt;Report&gt;(e =&gt; DoSomething(e));\u000a    reader.Filters = <span class=\"synStatement\">new<\/span>[] { <span class=\"synConstant\">&quot;.DS_Store&quot;<\/span>, <span class=\"synConstant\">&quot;Thumbs.db&quot;<\/span>, <span class=\"synConstant\">&quot;__MACOSX&quot;<\/span>, <span class=\"synConstant\">&quot;desktop.ini&quot;<\/span> };\u000a    reader.Extract(<span class=\"synSpecial\">@<\/span><span class=\"synConstant\">&quot;path\\to\\directory&quot;<\/span>, progress);\u000a}\u000a<\/pre>\u000a\u000a\u000a<p>ArchiveReader クラスは、オブジェクト生成時の第 1 引数に指定されたファイルに対して、解凍・展開するために必要な 7-Zip モジュールを自動的にロードします。また、第 2 引数はパスワードを表し、文字列を直接指定できる他、Cube.IQuery&lt;string&gt; を実装したオブジェクトを指定する事も可能です。このオブジェクトは、「パスワード・ダイアログ」などを通じてユーザにパスワードを尋ねるようなインターフェースを実現する際に利用します。<\/p>\u000a\u000a<p>Filters プロパティは <a href=\"https:\/\/www.cube-soft.jp\/cubeice\/\">CubeICE<\/a> のフィルタリング機能をライブラリとして実装したもので、解凍・展開時に除外するファイルまたはフォルダの一覧を指定します。最後に Extract メソッドに解凍・展開後のフォルダのパスを指定して、処理を開始します。この時、第 2 引数に System.IProgress&lt;Report&gt; を実装したオブジェクトを指定すると、このオブジェクトを通じて処理状況が通知されます。<\/p>\u000a\u000a<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink><span class=\"synStatement\">using<\/span> (var reader = <span class=\"synStatement\">new<\/span> ArchiveReader(<span class=\"synSpecial\">@<\/span><span class=\"synConstant\">&quot;path\\to\\archive&quot;<\/span>, <span class=\"synConstant\">&quot;password&quot;<\/span>))\u000a{\u000a    <span class=\"synComment\">\/\/ Save as &quot;path\\to\\directory\\{item.FullName}&quot;<\/span>\u000a    reader.Items[<span class=\"synConstant\">0<\/span>].Extract(<span class=\"synSpecial\">@<\/span><span class=\"synConstant\">&quot;path\\to\\directory&quot;<\/span>);\u000a}\u000a<\/pre>\u000a\u000a\u000a<p>ArchiveReader クラスの Items プロパティでは圧縮ファイルに含まれる各項目の情報 (ArchiveItem) を取得できますが、ArchiveItem に定義されている Extract メソッドを実行する事で個別に解凍・展開する事も可能です。ただし、開発環境で検証した限りですが、解凍・展開するフォーマットによっては処理時間が増大する場合があるようです。そのため、このメソッドは、あくまでも特定ファイルを解凍・展開したい時に使用する程度に留めておいた方が良いかもしれません。<\/p>\u000a\u000a<h4 id=\"圧縮ファイルの生成\">圧縮ファイルの生成<\/h4>\u000a\u000a<p>圧縮ファイルを生成するサンプルコードは下記になります。<\/p>\u000a\u000a<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink><span class=\"synStatement\">using<\/span> (var writer = <span class=\"synStatement\">new<\/span> ArchiveWriter(Format.Zip))\u000a{\u000a    writer.Add(<span class=\"synSpecial\">@<\/span><span class=\"synConstant\">&quot;path\\to\\file&quot;<\/span>);\u000a    writer.Add(<span class=\"synSpecial\">@<\/span><span class=\"synConstant\">&quot;path\\to\\directory_including_files&quot;<\/span>);\u000a    writer.Option  = <span class=\"synStatement\">new<\/span> ZipOption { CompressionLevel = CompressionLevel.Ultra };\u000a    writer.Filters = <span class=\"synStatement\">new<\/span>[] { <span class=\"synConstant\">&quot;.DS_Store&quot;<\/span>, <span class=\"synConstant\">&quot;Thumbs.db&quot;<\/span>, <span class=\"synConstant\">&quot;__MACOSX&quot;<\/span>, <span class=\"synConstant\">&quot;desktop.ini&quot;<\/span> };\u000a    \u000a    var progress = <span class=\"synStatement\">new<\/span> Progress&lt;Report&gt;(e =&gt; DoSomething(e));\u000a    writer.Save(<span class=\"synSpecial\">@<\/span><span class=\"synConstant\">&quot;path\\to\\save.zip&quot;<\/span>, <span class=\"synConstant\">&quot;password&quot;<\/span>, progress);\u000a}\u000a<\/pre>\u000a\u000a\u000a<p>ArchiveWriter クラスは、まず、圧縮形式を指定してオブジェクトを生成します。<a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem.SevenZip\/blob\/master\/Libraries\/Sources\/Format.cs\">Format<\/a> は、圧縮と解凍・展開で共用しているため大量の定義が存在しますが、ArchiveWriter として対応しているものは Zip, SevenZip, Tar, GZip, BZip2, XZ の 6 種類となります。そして、Add メソッドを通じて、生成されたオブジェクトに対してファイルまたはフォルダを追加していきます。尚、フォルダが指定された場合、フォルダに含まれるファイルおよびフォルダが再帰的に追加されていきます。最後に、Save メソッドに保存パスを指定して圧縮処理を開始します。<\/p>\u000a\u000a<p>Option プロパティには圧縮時の各種オプションを指定する事ができます。指定可能な内容については、<a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem.SevenZip\/blob\/master\/Libraries\/Sources\/ArchiveOption.cs\">ArchiveOption.cs<\/a> を参照下さい。まだ、基本的なオプションにしか対応できていませんが、追々、その他のものにも対応していく予定です。また、Filters プロパティおよび、Save メソッドの System.IProgress&lt;Report&gt; 引数の役割は解凍・展開の時と同様です。<\/p>\u000a\u000a<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink><span class=\"synStatement\">using<\/span> (var writer = <span class=\"synStatement\">new<\/span> ArchiveWriter(Format.Tar))\u000a{\u000a    writer.Option = <span class=\"synStatement\">new<\/span> TarOption\u000a    {\u000a        CompressionMethod = CompressionMethod.BZip2, <span class=\"synComment\">\/\/ GZip, BZip2, XZ or Copy<\/span>\u000a        CompressionLevel  = CompressionLevel.Ultra,\u000a    };\u000a\u000a    writer.Add(<span class=\"synSpecial\">@<\/span><span class=\"synConstant\">&quot;path\\to\\file&quot;<\/span>);\u000a    writer.Add(<span class=\"synSpecial\">@<\/span><span class=\"synConstant\">&quot;path\\to\\directory_including_files&quot;<\/span>);\u000a    writer.Save(<span class=\"synSpecial\">@<\/span><span class=\"synConstant\">&quot;path\\to\\save.tar.gz&quot;<\/span>);\u000a}\u000a<\/pre>\u000a\u000a\u000a<p>*.tar.gz のように Tar 系の圧縮ファイルを生成する場合、ArchiveWriter のコンストラクタには Format.Tar を指定してオブジェクトを生成します。その上で、Option プロパティに対して、TarOption クラスを利用して圧縮方式を指定します。<\/p>\u000a\u000a<h4 id=\"進捗状況のレポート機能\">進捗状況のレポート機能<\/h4>\u000a\u000a<p>System.IProgress&lt;Report&gt; を通じて通知される進捗内容は下記になります。<\/p>\u000a\u000a<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink><span class=\"synType\">public<\/span> <span class=\"synType\">class<\/span> Report\u000a{\u000a    <span class=\"synType\">public<\/span> ReportStatus Status { get; }\u000a    <span class=\"synType\">public<\/span> <span class=\"synType\">public<\/span> Information Current { get; }\u000a    <span class=\"synType\">public<\/span> <span class=\"synType\">long<\/span> Count { get; }\u000a    <span class=\"synType\">public<\/span> <span class=\"synType\">long<\/span> TotalCount { get; }\u000a    <span class=\"synType\">public<\/span> <span class=\"synType\">long<\/span> Bytes { get; }\u000a    <span class=\"synType\">public<\/span> <span class=\"synType\">long<\/span> TotalBytes { get; }\u000a    <span class=\"synType\">public<\/span> <span class=\"synType\">double<\/span> Ratio =&gt; TotalBytes &gt; <span class=\"synConstant\">0<\/span> ? Bytes \/ (<span class=\"synType\">double<\/span>)TotalBytes : <span class=\"synConstant\">0.0<\/span>;\u000a}\u000a<\/pre>\u000a\u000a\u000a<p>TotalCount は圧縮または解凍・展開対象となるファイルおよびフォルダの総数、Count は Bytes は処理の終了した数を示し、TobalBytes および Bytes はバイト数に関する内容を表します。Current は現在処理中のファイルまたはフォルダの情報を保持し、Status は <strong>Current の処理状況<\/strong> を Begin（開始直前）、End（終了）、Progress（処理中）で示します。<\/p>\u000a\u000a<p>尚、Status および Current に関しては現時点では解凍・展開用と言う性質が強く、圧縮時にはあまり信頼できません（一応 Begin は通知されますが、End の通知は未実装）。これは、圧縮処理は 7-Zip 自体がマルチスレッド対応している事もあり、正確に通知する事が難しいと言う課題が残っているためです。この辺りをどうするかは、今後、検討していきます。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20181025\/cubeice-as-7zip-library","PublishTime":"\/Date(1571912401000+0900)\/","Status":1,"Summary":"圧縮・解凍ソフト CubeICE をゼロから改修 に記載した通り、昨年、CubeICE に対して大幅な修正を実施しましたが、この際にライブラリとしても利用できるようにインターフェース（クラスやメソッド）を整理する事をテーマの一つに設定していました。そこで、この記事では CubeICE （正確には Cube.FileSystem.SevenZip.dll）を 7-Zip ライブラリとして利用するため","Title":"7-Zip ライブラリとしての CubeICE"},{"Categories":[],"Content":"<p><a href=\"https:\/\/www.cube-soft.jp\/cubeice\/\">CubeICE 0.9.1β<\/a> をリリースしました。0.9.1βでの修正点は下記の通りです。<\/p>\u000a\u000a<h4>未対応形式のファイルが指定された時のエラーメッセージを修正<\/h4>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191024\/20191024191106.png\" alt=\"CubeICE エラーメッセージ\" \/><\/p>\u000a\u000a<p>CubeICE で未対応形式、または圧縮形式ではないファイルを指定した際のエラーメッセージを分かりやすい文言に修正しました。尚、上記のエラーメッセージが表示された場合、指定したファイルが圧縮ファイルではない可能性が高いと予想されますので、今一度、指定したファイル内容をご確認頂くようお願いいたします。<\/p>\u000a\u000a<h4>ファイル一覧の表示機能を完全に無効化できるように修正<\/h4>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20191024\/20191024191223.png\" alt=\"ファイル一覧の表示機能\" \/><\/p>\u000a\u000a<p>CubeICE には、圧縮ファイルにマウスカーソルを当てた時にファイル一覧を表示する機能があります。この機能は、CubeICE 設定の「詳細」タブ、「圧縮ファイルのツールチップにファイル一覧を表示する」の項目より有効・無効の設定が可能です。ただ、これまでのバージョンでは、無効時には該当のライブラリ（シェル拡張）をロードした上で無効時の、すなわち標準と同じ挙動を示すようにしていました。<\/p>\u000a\u000a<p>0.9.1βでは、無効設定時にはシェル拡張用ライブラリの読み込み自体を無効化するように修正しました。尚、これに伴い、CubeICE 設定にて、該当設定を変更する際にも管理者権限が要求されるようになります。<\/p>\u000a\u000a<h4>その他の修正<\/h4>\u000a\u000a<p>その他の修正は下記の通りです。<\/p>\u000a\u000a<ul>\u000a<li>特定の条件でファイルの関連付け設定が機能しない不都合を修正しました。<\/li>\u000a<li>タスクバーの進捗表示機能に関する不都合を修正しました。<\/li>\u000a<li>パスワード入力画面で、特定の条件で OK ボタンが押せなくなる不都合を修正しました。<\/li>\u000a<li><a href=\"https:\/\/www.7-zip.org\/\">7-Zip 19.00<\/a> の修正を適用しました。<\/li>\u000a<\/ul>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20190408\/cubeice-0.9.1b","PublishTime":"\/Date(1571912110000+0900)\/","Status":1,"Summary":"CubeICE 0.9.1β をリリースしました。0.9.1βでの修正点は下記の通りです。 未対応形式のファイルが指定された時のエラーメッセージを修正 CubeICE で未対応形式、または圧縮形式ではないファイルを指定した際のエラーメッセージを分かりやすい文言に修正しました。尚、上記のエラーメッセージが表示された場合、指定したファイルが圧縮ファイルではない可能性が高いと予想されますので、今一度、指","Title":"CubeICE 0.9.1β"},{"Categories":[],"Content":"<p>先日 <a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\">CubePDF Utility 0.5.0β<\/a> のリリースが完了し、数ヶ月にわたる CubePDF シリーズの改修、さらに言えば、去年からスタートさせていた CubeICE を含むキューブ・ソフト初期のソフトウェア大改修プロジェクトがようやくひと段落しました。そこで、この記事では CubePDF シリーズ、特に CubePDF Utility の改修後書を記載していきます。<\/p>\u000a\u000a<ul class=\"table-of-contents\">\u000a    <li><a href=\"#はじめに\">はじめに<\/a><\/li>\u000a    <li><a href=\"#PDFium-の採用\">PDFium の採用<\/a><\/li>\u000a    <li><a href=\"#WPF-の再入門\">WPF の再入門<\/a><\/li>\u000a    <li><a href=\"#正式リリースに向けて\">正式リリースに向けて<\/a><\/li>\u000a<\/ul>\u000a\u000a<h4 id=\"はじめに\">はじめに<\/h4>\u000a\u000a<p>CubePDF シリーズには全部で 6 個のソフトウェアが存在しますが、今回改修した <a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\">CubePDF<\/a>、<a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\">CubePDF Utility<\/a>、それに簡易版 CubePDF Utility として位置付けている <a href=\"https:\/\/www.cube-soft.jp\/cubepdfpage\/\">CubePDF Page<\/a> を始めとして、多くのユーザにご利用頂いているようです。特に、CubePDF は単純な累計ダウンロード数であれば 1,000 万を超えるような数字となっており、約 8 年前に最初のバージョンをリリースした時には、ここまで育つとは思いもよらなかったと言うのが正直な感想です。<\/p>\u000a\u000a<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20180928\/20180928163656.png\" alt=\"CubePDF Utility\" \/><\/a><\/p>\u000a\u000a<p>そんな CubePDF シリーズですが、10 年近い年月が経過する内に、ソフトウェアの保守がどんどん大変になっていくと言う状態が続いていました。また、CubePDF シリーズ内でのソースコードの共有が上手くいっていなかった事や、CubePDF Utility に存在する諸問題を解決するために利用ライブラリを変更したい等、様々な課題を解決するに際して、一度ソースコードを整理しておきたいと思ったのが今回の大改修を実施した理由です。<\/p>\u000a\u000a<p>余談として、本当であれば CubePDF の話を主役に据えたかったのですが、CubePDF に関しては思ったほど書く事がないと言う理由で、今回の主役は CubePDF Utility に譲っています。CubePDF は、私が人生の中で初めてゼロから作成した GUI アプリケーションですが、ソースコードの保守と言う観点で見ると、他のものに比べれば意外と上手くいってる事は嬉しい誤算でした。これは、View 自体はさほど複雑ではない等の理由によるものだろうと思いますが、そう言った点も含めて、いろいろと予想外だったソフトウェアです。<\/p>\u000a\u000a<h4 id=\"PDFium-の採用\">PDFium の採用<\/h4>\u000a\u000a<p>CubePDF Utility の改修における大きな変更点の一つとして <a href=\"https:\/\/pdfium.googlesource.com\/pdfium\/\">PDFium<\/a> の採用が挙げられます。CubePDF Utility は、これまでレンダリングエンジンとして <a href=\"https:\/\/mupdf.com\/\">MuPDF<\/a> を .NET Framework 用にラップした <a href=\"https:\/\/github.com\/cube-soft\/PDFLibNet\">PDFLibNet<\/a> と言うライブラリを使用していましたが、Unicode 版としてビルドされていないためにファイルパスの扱いで問題が発生する事があり、サムネイル画像が表示されない等の原因にもなっていました。<\/p>\u000a\u000a<p>一方 PDFium では、下記のように必要なタイミングで必要なバイトデータを返す関数ポインタを指定するためのインターフェースが公開されています。このインターフェースを利用してファイルの操作自体は C#\/.NET 側で行う事により、これまでの懸念事項であったパスの問題を解決する事ができました (<a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/blob\/master\/Libraries\/Pdfium\/Sources\/Details\/PdfiumReader.cs\">PdfiumReader.cs<\/a>)。<\/p>\u000a\u000a<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink>_core = PdfiumApi.FPDF_LoadCustomDocument(\u000a    <span class=\"synStatement\">new<\/span> FileAccess\u000a    {\u000a        Length    = (<span class=\"synType\">uint<\/span>)_stream.Length,\u000a        GetBlock  = Marshal.GetFunctionPointerForDelegate(_delegate),\u000a        Parameter = IntPtr.Zero,\u000a    },\u000a    password\u000a);\u000a<\/pre>\u000a\u000a\u000a<h4 id=\"WPF-の再入門\">WPF の再入門<\/h4>\u000a\u000a<p>CubePDF Utility は、約 6 年前に WPF を用いて作成した初めての GUI アプリケーションでしたが、WPF での代表的な開発パターンである Model-View-ViewModel (MVVM) への理解が足りなかった事が、その後の保守性の悪さに繋がりました（所謂 Fat View、Fat ViewModel 問題）。また、完成したアプリケーションを実際に試してみるとコールドスタートが非常に遅いと言う結果となったため、これ以降の何年もの間、新規プロジェクトにおける WPF の採用を見送る原因にもなりました。キューブ・ソフトで公開している Windows ソフトウェアの中で CubePDF Utility のみスプラッシュ画面を表示しているのも、このためです。<\/p>\u000a\u000a<p>しかし、ここ数年、システムドライブに採用されるストレージが HDD から SSD に変化するのにつれて、コールドスタートの問題は相対的に小さなものとなりました。また、リリース後に何度か実施した調査によると、どうも <a href=\"https:\/\/clown.hatenablog.jp\/entry\/20130419\/disable_ribbon_gradient\">利用している Ribbon ライブラリ<\/a> の影響も大きいと言う結果が出ていたため、今回、利用ライブラリを <a href=\"https:\/\/github.com\/fluentribbon\/Fluent.Ribbon\">Fluent.Ribbon<\/a> に変更する事で改善を試みています<a href=\"#f-3bd5b421\" name=\"fn-3bd5b421\" title=\"ただし、Fluent.Ribbon は .NET Framework 4 以降でないと利用できないため、.NET 3.5 版では従来の Ribbon ライブラリを使用しています。\">*1<\/a>。こう言った状況の変化もあって WPF 自体を忌避する理由も徐々に薄れているため、2018 年の個人的なテーマの一つとして WPF の再入門を設定し、これまでに CubeRSS Reader の新規作成と CubePDF Utility の改修を行ってきました。<\/p>\u000a\u000a<p>その成果の一つが下図になります。これは CubePDF Utility のメイン画面を表す MainWindow.xaml.cs の改修前後における記述行数の変化を示したものですが、<a href=\"https:\/\/github.com\/cube-soft\/CubePdfUtility2\/blob\/final\/CubePdfUtility2\/MainWindow.xaml.cs\">2,120 行<\/a> から <a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/blob\/master\/Applications\/Editor\/Forms\/Views\/MainWindow.xaml.cs\">0 行<\/a> に削減できた事が分かります（Visual Studio による自動生成部分を除く）。もちろん、実際に 1 行も記述せずに実現できている訳ではないのですが、インパクトの大きさを示すのには良い例かなと思って紹介します。<\/p>\u000a\u000a<p><a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20180928\/20180928184650.png\" alt=\"MainWindow.xaml.cs コード行数の変化\" \/><\/a><\/p>\u000a\u000a<p>今回、個人的にもっとも感動したのは Expression Blend SDK によって提供される Behavior と言う概念でした。WinForms を始めとして、EventHandler ベースの GUI プログラミングはややもすると View がゴチャゴチャする (Fat View) と言う問題点が指摘されますが、この原因の一つに「EventHandler をどこに記述すれば良いのか判断できない」と言うものがあるように思います。自分自身を振り返っても、EventHandler の記述内容を見ると public なプロパティおよびメソッドのみで完結しているので必ずしも MainForm.cs のような場所に記述する必要はないが、それ以外の適当な場所も思いつかないため、結局そこに書いてしまう（そして、どんどんと膨れ上がる）と言う経験が多々ありました。<\/p>\u000a\u000a<p>Behavior と言う概念は、この問題に対して「単一、あるいは一纏まりの View の動作に対して名前を付け、クラス化する」と言う解決策を示してくれました。さらに、これによって「View の動作単位での汎用化」と言う可能性も視野に入るようになり、特に MVVM における Messenger (EventAggregator) パターンと併用する事で、かなり柔軟な記述が可能となってきました。例えば、CubePDF Utility では「メッセージとしてサブ画面用の  ViewModel オブジェクトを送信すると、View は ViewModel の型に紐づけられた SubView を生成して DataContext にその ViewModel を設定し、ShowDialog メソッドを実行する」と言う「動作」を予め作成しておく事で、View の個別の生成処理をかなり削減するのに成功しています。<\/p>\u000a\u000a<pre class=\"code lang-xml\" data-lang=\"xml\" data-unlink><span class=\"synIdentifier\">&lt;<\/span><span class=\"synSpecial\">i<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">Interaction<\/span><span class=\"synComment\">.<\/span><span class=\"synIdentifier\">Behaviors&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;<\/span><span class=\"synSpecial\">xb<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">DialogBehavior \/&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;<\/span><span class=\"synSpecial\">xb<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">OpenFileDialogBehavior \/&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;<\/span><span class=\"synSpecial\">xb<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">SaveFileDialogBehavior \/&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;<\/span><span class=\"synSpecial\">xb<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">UriBehavior \/&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;<\/span><span class=\"synSpecial\">xb<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">CloseBehavior \/&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;<\/span><span class=\"synSpecial\">xb<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">ClosingBehavior <\/span><span class=\"synType\">Command<\/span>=<span class=\"synConstant\">&quot;{Binding Ribbon.Close.Command}&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;<\/span><span class=\"synSpecial\">my<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">PasswordWindowBehavior \/&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;<\/span><span class=\"synSpecial\">my<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">PreviewWindowBehavior \/&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;<\/span><span class=\"synSpecial\">my<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">InsertWindowBehavior \/&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;<\/span><span class=\"synSpecial\">my<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">RemoveWindowBehavior \/&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;<\/span><span class=\"synSpecial\">my<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">MetadataWindowBehavior \/&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;<\/span><span class=\"synSpecial\">my<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">EncryptionWindowBehavior \/&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;<\/span><span class=\"synSpecial\">my<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">SettingsWindowBehavior \/&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;<\/span><span class=\"synSpecial\">my<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">DragFileBehavior <\/span><span class=\"synType\">Command<\/span>=<span class=\"synConstant\">&quot;{Binding Drop}&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a<span class=\"synIdentifier\">&lt;\/<\/span><span class=\"synSpecial\">i<\/span><span class=\"synComment\">:<\/span><span class=\"synIdentifier\">Interaction<\/span><span class=\"synComment\">.<\/span><span class=\"synIdentifier\">Behaviors&gt;<\/span>\u000a<\/pre>\u000a\u000a\u000a<p>Behavior と言うライブラリ自体は 6 年前から使用していたのですが、今回、改めて見直す事によって View との連携方法を大きく前進できたのは非常に良かったように思います。<\/p>\u000a\u000a<h4 id=\"正式リリースに向けて\">正式リリースに向けて<\/h4>\u000a\u000a<p>キューブ・ソフトで公開しているソフトウェアの多くは β や RC を名乗っています。「いつまで β なんだよ」と言う指摘を見かける事もありますが、これは私自身が長年、正式リリースを名乗って良いのかどうか判断できないし自信もない、と感じていたためと言う面がありました。<\/p>\u000a\u000a<p>この問題を克服するために、2017 年から「アプリケーション部分を含めたユニットテストの拡充と CI 環境による継続的なテスト」と言う課題に取り組んできました（参考：<a href=\"https:\/\/clown.hatenablog.jp\/entry\/cubeice\">圧縮・解凍ソフト CubeICE をゼロから改修<\/a>）。そして、現時点で振り返ってみると、まだ完璧とは言い切れませんが、ここ 1 年のものが実を結びつつあると言う実感がでてきました。もう少し時間がかかりそうですが、順次、正式リリースと言えるように今後も環境を整えていく予定です。<\/p>\u000a\u000a<p>また、<a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\">Cube.Pdf<\/a> プロジェクトに関しては、ライブラリ部分が CubePDF シリーズで必要な範囲しか実装できておらず不十分なため、もう少し頑張って実装したいと言う思いがあります。こちらに関しては、どうしても優先度が下がりがちになってしまうのですが、全体のスケジュールを見ながら上手く進めていきたいと思います。<\/p>\u000a<div class=\"footnote\">\u000a<p class=\"footnote\"><a href=\"#fn-3bd5b421\" name=\"f-3bd5b421\" class=\"footnote-number\">*1<\/a><span class=\"footnote-delimiter\">:<\/span><span class=\"footnote-text\">ただし、Fluent.Ribbon は .NET Framework 4 以降でないと利用できないため、.NET 3.5 版では従来の Ribbon ライブラリを使用しています。<\/span><\/p>\u000a<\/div>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20180928\/cubepdf","PublishTime":"\/Date(1571885946000+0900)\/","Status":2,"Summary":"先日 CubePDF Utility 0.5.0β のリリースが完了し、数ヶ月にわたる CubePDF シリーズの改修、さらに言えば、去年からスタートさせていた CubeICE を含むキューブ・ソフト初期のソフトウェア大改修プロジェクトがようやくひと段落しました。そこで、この記事では CubePDF シリーズ、特に CubePDF Utility の改修後書を記載していきます。 はじめに PDFi","Title":"CubePDF シリーズの大改修"},{"Categories":[],"Content":"<p>先日、<a href=\"https:\/\/www.ghostscript.com\/\">Ghostscript<\/a> が 9.26 にバージョンアップしました。リリースノートによると Ghostscript 9.26 では再び、セキュリティ問題に関する修正が実施されているようです。<a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\">CubePDF<\/a> も、近日中に Ghostscript のバージョンアップを含めた最新版をリリースする予定ですが、この記事では CubePDF に含まれる Ghostscript を手動で更新する方法について記載します。<\/p>\u000a\u000a<p>まず、CubePDF のバージョンを確認して下さい。CubePDF のバージョンは、適当なものを CubePDF プリンタで印刷し、表示されるメイン画面の「その他」タブで確認する事ができます。<\/p>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20181128\/20181128215852.png\" alt=\"CubePDF バージョン情報\" \/><\/p>\u000a\u000a<p>該当項目が存在しない場合は、CubePDF のバージョンが古いため最新版にアップデートして下さい。CubePDF は 1.0.0RC12 にてフォルダ構成等を変更しているので、バージョンが <strong>1.0.0RC12 未満<\/strong>（1.0.0RC11 や 0.9.9β など）の場合は、必ず最新版に更新するようお願いします。バージョンが問題なければ、その右隣に記述されている文字列（<strong>x86 または x64<\/strong>）を覚えておいて下さい。<\/p>\u000a\u000a<p>次に、<a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/releases\">Releases - Cube.Pdf - GitHub<\/a> へ移動します。ここで、先ほどのバージョン表示画面で確認した x86\/x64 に対応する Ghostscript の最新版 Zip ファイル（例えば、gs-9.26-x86.zip など）をダウンロードして下さい。<\/p>\u000a\u000a<p><a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/releases\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20181128\/20181128182015.png\" alt=\"Ghostscript の差し替え方法\" \/><\/a><\/p>\u000a\u000a<p>ダウンロード終了後、解凍・展開したフォルダにある gsdll32.dll および各種フォルダを全て CubePDF のインストールフォルダ（初期設定では C:\\Program Files\\CubePDF）にコピーして差し換えると、手動による Ghostscript の更新作業は完了です。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20181129\/cubepdf-and-ghostscript","PublishTime":"\/Date(1571885900000+0900)\/","Status":2,"Summary":"先日、Ghostscript が 9.26 にバージョンアップしました。リリースノートによると Ghostscript 9.26 では再び、セキュリティ問題に関する修正が実施されているようです。CubePDF も、近日中に Ghostscript のバージョンアップを含めた最新版をリリースする予定ですが、この記事では CubePDF に含まれる Ghostscript を手動で更新する方法について","Title":"CubePDF に含まれる Ghostscript を手動で更新する方法"},{"Categories":[],"Content":"<p>ブログの URL を <a href=\"https:\/\/clown.cube-soft.jp\/\">https:\/\/clown.cube-soft.jp\/<\/a> に変更しました。近年、このブログは Cube シリーズに関する開発ブログの性質が強くなっていましたが、この度、URL を変更して正式に開発ブログと位置付ける事にしました。また、キューブ・ソフトに関わるリリース通知などは、これまで <a href=\"https:\/\/blog.cube-soft.jp\/\">https:\/\/blog.cube-soft.jp\/<\/a> で行っていましたが、今後はそれらもこのブログで兼務する予定です。<\/p>\u000a\u000a<p>以上、まずは事務連絡。せっかくなので、この記事ではこのブログの「これまで」と「これから」について記述しようと思います。<\/p>\u000a\u000a<ul class=\"table-of-contents\">\u000a    <li><a href=\"#ブログの始まり\">ブログの始まり<\/a><\/li>\u000a    <li><a href=\"#ブログの休止と再開\">ブログの休止と再開<\/a><\/li>\u000a    <li><a href=\"#ブログに何を書くかあるいは何を書かないか\">ブログに何を書くか？あるいは何を書かないか？<\/a><\/li>\u000a<\/ul>\u000a\u000a<h4 id=\"ブログの始まり\">ブログの始まり<\/h4>\u000a\u000a<p>このブログは 2005 年 10 月に、はてなブログの前身である「はてなダイアリー」でスタートします。ブログを開設した動機は、大学院に進学したため「論文を書くにあたり、日本語の文章を書く練習をしたい」と言うものでした。私は飛び級制度を利用して大学 3 年生から大学院に進学した都合上、卒業論文を経ておらず（退学扱い）論文を書くと言う行為は大学院生になって初めて経験しました。論文自体は非常に苦しみましたが、「日本語の文章を書く」と言う作業を苦にする事はなくなったので、この時の選択は非常に良かったと今でも思っています。<\/p>\u000a\u000a<p>ブログに関しては、しばらく取り留めもない更新が続きました。現在であれば Twitter に投稿して終わりにするような記事も多く、ブログ記事として公開し続けるのは何だか恥ずかしいような気持ちもあります。また、ブログ読者もそのほとんどが大学時代の友人だったと記憶しています。そう言った状況が半年ほど続きましたが、以下の記事を公開した事で大きく変わりました。<\/p>\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/clown.cube-soft.jp\/entry\/20060308\/p1\">コミュニケーション能力 - Life like a clown<\/a><\/li>\u000a<\/ul>\u000a\u000a\u000a<p>上記は「いろいろな人が『コミュニケーション』と言う単語を口にするが、各人毎に『コミュニケーション』と言う単語の指しているものが、どうも違うような気がする」と言う漠然とした違和感を記事にしたものだったのですが、この記事が <a href=\"https:\/\/b.hatena.ne.jp\/\">はてなブックマーク<\/a> を経由して、多くの「会った事もない人々」に読まれる事となりました。この時に初めて、はてなブックマーク、あるいはソーシャルメディアと言うものの存在を認識し、これ以降それらを強く意識するようになっていきます。2010 年代に入り Twitter に代表されるソーシャルメディアの影響力が良くも悪くも強くなっていく中、早い段階で所謂「バズる」と言う現象を体験できた事は Web 上で何らかの情報を発信していく上でプラスに働いたように感じます。<\/p>\u000a\u000a<h4 id=\"ブログの休止と再開\">ブログの休止と再開<\/h4>\u000a\u000a<p>このブログは 2014 年から 2017 年まで、まったく更新しない期間がありました。理由は私生活の変化によってブログを更新する精神的な余裕がなくなったと言うもので、当初の予定では 1, 2 ヶ月程度で復帰する予定でしたが、現実には 3 年もの空白期間を作る事となりました。<\/p>\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/clown.cube-soft.jp\/entry\/20070610\/p1\">それでも更新頻度は重要である - Life like a clown<\/a><\/li>\u000a<\/ul>\u000a\u000a\u000a<p>10 年以上前に上記事を書いた事を覚えています。内容自体は現在の自分から見て賛同できるかどうかは半々程度ですが、この空白の 3 年間で痛感した事は「継続する事の大切さ」でした。更新を続けている間、特にその行為に対して苦痛に感じた事はなかったのですが、更新しなくなって 1 ヶ月もすると途端にブログを更新する事（再開する事）を面倒に感じるようになってきました。<\/p>\u000a\u000a<p>この 3 年間で得た結論としては、何かを継続するために必要なものは、言い方は悪いですが「惰性」だろうと言うものです。「情熱」や「やる気」と言ったものは、何かを始める際には非常に重要な要素となりますが、これだけで継続できる期間は多く見積もっても半年程度だろうと言うのが現在までの感想です。それ以上の継続性を求められた場合、必要な要素は良く言うと「習慣化」、悪く言うと先ほど挙げた「惰性」と言う気がします。<\/p>\u000a\u000a<h4 id=\"ブログに何を書くかあるいは何を書かないか\">ブログに何を書くか？あるいは何を書かないか？<\/h4>\u000a\u000a<p>前述したように、ブログの更新を継続させると言う観点から見ると「何でも良いから、とにかく更新する（習慣化、あるいは惰性化させる）」事が重要であると感じています。その一方で、Web と言うものの社会的影響力が強まり、「デマ」や「フェイクニュース」と言うキーワードが取り沙汰される現代において「何を書くべきか？」と言う問いを考える機会も増えてきました。<\/p>\u000a\u000a<p>私自身を振り返っても、ブログを始めてから結構な期間は「目に止まった『刺激的な』ニュース記事に対して適当な感想を書く」と言う更新を繰り返していました。この手法は「とにかく更新する」と言う観点で見ると有効なのですが、言及した内容に対して検証不十分である事が多く、デマ情報を拡散する危険性もあります。他人に対してどうこう言うつもりはありませんが、自分自身がこの態度を取り続けるのはやはり良くない、と言うのが空白の 3 年間で出した結論でした。<\/p>\u000a\u000a<p>ブログ再開後に自らに課した規則は「自分で継続的に調査する気力のある分野のみ、情報発信していく」と言うものです。現在で言えば、Windows アプリケーションを始めとした開発やプログラミング全般に関する内容、そして Web をテーマとした諸問題の一部辺りが該当するでしょうか。それ以外の、例えば時事問題のような事象に関しては「情報収集はするが、それに対して自分が何かを言う事はしない」ように心がけています。Twitter の投稿内容まで広げるとまだまだ徹底できてるとは言い難いですが、今後もこの方針を維持できればと思っています。<\/p>\u000a\u000a<p>そう言った訳で、このブログでは今後、Cube シリーズに関する内容、Windows アプリケーション等の開発およびプログラミングに関する内容、そして Web をテーマとした諸問題の一部を題材に更新を続けていく予定です。かつてのような更新頻度を保つことができなくなってしまいましたが、うまく惰性化できるように、もう少し頑張ってみようと思います。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20191015\/blog-future","PublishTime":"\/Date(1571194415000+0900)\/","Status":2,"Summary":"ブログの URL を https:\/\/clown.cube-soft.jp\/ に変更しました。近年、このブログは Cube シリーズに関する開発ブログの性質が強くなっていましたが、この度、URL を変更して正式に開発ブログと位置付ける事にしました。また、キューブ・ソフトに関わるリリース通知などは、これまで https:\/\/blog.cube-soft.jp\/ で行っていましたが、今後はそれらもこの","Title":"このブログのこれまでとこれから"},{"Categories":[],"Content":"<p>先日、<a href=\"https:\/\/clown.hatenablog.jp\/entry\/20181025\/cubeice-as-7zip-library\">7-Zip ライブラリとしての CubeICE <\/a> と言う記事を公開しましたが、ライブラリ化の試みは CubePDF シリーズでも行っています。CubePDF シリーズは <a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\">Cube.Pdf<\/a> と言うリポジトリで管理しており、ライブラリ部分は <a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/tree\/master\/Libraries\">Libraries<\/a> に、最終的なアプリケーション部分は <a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/tree\/master\/Applications\">Applications<\/a> に配置しています。この記事では、CubePDF ライブラリの内 Ghostscript を C# から利用できるものを紹介します。<\/p>\u000a\u000a<ul class=\"table-of-contents\">\u000a    <li><a href=\"#事前準備\">事前準備<\/a><\/li>\u000a    <li><a href=\"#簡単なサンプルコード\">簡単なサンプルコード<\/a><\/li>\u000a    <li><a href=\"#CubePdfGhostscript-の詳細\">Cube.Pdf.Ghostscript の詳細<\/a><\/li>\u000a    <li><a href=\"#その他の注意事項\">その他の注意事項<\/a><\/li>\u000a<\/ul>\u000a\u000a<h4 id=\"事前準備\">事前準備<\/h4>\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/www.nuget.org\/packages\/Cube.Pdf.Ghostscript\/\">Cube.Pdf.Ghostscript - NuGet<\/a><\/li>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/\">Cube.Pdf - GitHub<\/a><\/li>\u000a<\/ul>\u000a\u000a\u000a<p>Cube.Pdf および Cube.Pdf.Ghostscript は <a href=\"https:\/\/www.nuget.org\/packages\/Cube.Pdf.Ghostscript\/\">NuGet<\/a> 経由で取得する事ができますが、この中には gsdll32.dll が含まれていないので別途ダウンロードして実行ディレクトリに配置して下さい。gsdll32.dll は <a href=\"https:\/\/www.ghostscript.com\/\">www.ghostscript.com<\/a> からインストーラ経由で取得できる他、Zip 形式で圧縮したものを <a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/releases\">GitHub Releases<\/a> にも公開しています。<\/p>\u000a\u000a<p>尚、C# 等から Unmanaged な dll を利用する場合 x86\/x64 の設定が問題になるので、特に Any CPU でビルドする場合、「32 ビットを優先 (Prefer 32-bit)」の項目が有効かどうかを含めて、どちらの dll を必要とするか注意して下さい。また、オリジナルの x64 版は gsdll64.dll と言うファイル名となっているので、gsdll32.dll と言うファイル名に変更して利用して下さい（GitHub Releases で公開しているものは変更済みです）。<\/p>\u000a\u000a<h4 id=\"簡単なサンプルコード\">簡単なサンプルコード<\/h4>\u000a\u000a<p>まずは簡単なサンプルとして、PostScript ファイルを PDF に変換するコードを記載します。PDF に変換する場合は PdfConverter クラスを利用します。ページサイズや解像度、埋め込み画像の圧縮方式などを設定するプロパティが用意されているので、必要な場合は値を設定し、Invoke メソッドを実行する事で変換が完了します。<\/p>\u000a\u000a<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink><span class=\"synComment\">\/\/ using Cube.Pdf.Ghostscript;<\/span>\u000avar converter = <span class=\"synStatement\">new<\/span> PdfConverter\u000a{\u000a    Paper        = Paper.Auto,\u000a    Orientation  = Orientation.Auto,\u000a    ColorMode    = ColorMode.Rgb,\u000a    Resolution   = <span class=\"synConstant\">600<\/span>,\u000a    Compression  = Encoding.Jpeg,\u000a    Downsampling = Downsampling.None,\u000a    Version      = <span class=\"synStatement\">new<\/span> PdfVersion(<span class=\"synConstant\">1<\/span>, <span class=\"synConstant\">7<\/span>),\u000a};\u000aconverter.Invoke(<span class=\"synSpecial\">@<\/span><span class=\"synConstant\">&quot;path\\to\\src.ps&quot;<\/span>, <span class=\"synSpecial\">@<\/span><span class=\"synConstant\">&quot;path\\to\\dest.pdf&quot;<\/span>);\u000a<\/pre>\u000a\u000a\u000a<h4 id=\"CubePdfGhostscript-の詳細\">Cube.Pdf.Ghostscript の詳細<\/h4>\u000a\u000a<p>Ghostscript API では gsapi_init_with_args() と言う関数で変換処理を実行しますが、この関数はコマンドライン版とまったく同じ引数を指定する事ができます<a href=\"#f-2d887ec3\" name=\"fn-2d887ec3\" title=\"コマンドラインの引数をそのまま指定するせいか、最初の引数は無視されます\">*1<\/a>。Ghostscript のコマンドラインは、下記のように 3 種類に大別されます。<\/p>\u000a\u000a<pre class=\"code\" data-lang=\"\" data-unlink>gs &lt;通常オプション&gt; -c &lt;PostScript コード&gt; -f &lt;入力ファイル&gt;<\/pre>\u000a\u000a\u000a<p>Cube.Pdf.Ghostscript の基底クラスである <a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/blob\/master\/Libraries\/Ghostscript\/Sources\/Converter.cs\">Converter<\/a> は、上記のコマンドラインを生成して変換を実行するための非常に薄いラッパーとなっています。<\/p>\u000a\u000a<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink><span class=\"synType\">public<\/span> <span class=\"synType\">class<\/span> Converter\u000a{\u000a    <span class=\"synType\">public<\/span> Converter(Format format);\u000a    <span class=\"synType\">public<\/span> ICollection&lt;Argument&gt; Options;\u000a    <span class=\"synType\">public<\/span> ICollection&lt;Code&gt; Codes;\u000a    <span class=\"synType\">public<\/span> <span class=\"synType\">void<\/span> Invoke(<span class=\"synType\">string<\/span> src, <span class=\"synType\">string<\/span> dest);\u000a}\u000a<\/pre>\u000a\u000a\u000a<p>使い方としては、まずコンストラクタに変換対象となる <a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/blob\/master\/Libraries\/Ghostscript\/Sources\/Parameters\/Format.cs\">Format<\/a> を指定します。次に、Options プロパティには通常オプション、Codes プロパティには PostScript コードをそれぞれ必要な数だけ指定します。そして、最後に Invoke メソッドに変換元ファイル (PS, EPS, PDF) および保存先のパスを指定して変換を実行します。<\/p>\u000a\u000a<p>通常時は基底クラスである Converter をそのまま使用するよりも、各種継承クラスを必要に応じて使用する方が便利です。Cube.Pdf.Ghostscript では現在、以下の変換クラスを提供しています。これらのクラスは、ページサイズや画像の圧縮形式などを指定するためのプロパティを用意しており、設定値に応じた Ghostscript 引数を自動的に追加します。<\/p>\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/blob\/master\/Libraries\/Ghostscript\/Sources\/DocumentConverter.cs\">DocumentConverter<\/a> ... PS\/EPS\/PDF\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/blob\/master\/Libraries\/Ghostscript\/Sources\/PdfConverter.cs\">PdfConverter<\/a><\/li>\u000a<\/ul>\u000a<\/li>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/blob\/master\/Libraries\/Ghostscript\/Sources\/ImageConverter.cs\">ImageConverter<\/a> ... PNG\/JPEG\/BMP\/TIFF\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/blob\/master\/Libraries\/Ghostscript\/Sources\/JpegConverter.cs\">JpegConverter<\/a><\/li>\u000a<\/ul>\u000a<\/li>\u000a<\/ul>\u000a\u000a\u000a<p>対応するプロパティが存在せず、自ら Ghostscript の引数を追加する必要がある場合、Options 引数に Argument オブジェクトを追加します。<a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/blob\/master\/Libraries\/Ghostscript\/Sources\/Argument.cs\">Argument<\/a> クラスのコンストラクタは下記のようになっています。<\/p>\u000a\u000a<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink><span class=\"synType\">public<\/span> <span class=\"synType\">class<\/span> Argument\u000a{\u000a    <span class=\"synType\">public<\/span> Argument(<span class=\"synType\">string<\/span> name, <span class=\"synType\">bool<\/span> <span class=\"synStatement\">value<\/span>);\u000a    <span class=\"synType\">public<\/span> Argument(<span class=\"synType\">string<\/span> name, <span class=\"synType\">int<\/span> <span class=\"synStatement\">value<\/span>);\u000a    <span class=\"synType\">public<\/span> Argument(<span class=\"synType\">string<\/span> name, <span class=\"synType\">string<\/span> <span class=\"synStatement\">value<\/span>);\u000a    <span class=\"synType\">public<\/span> Argument(<span class=\"synType\">char<\/span> type);\u000a    <span class=\"synType\">public<\/span> Argument(<span class=\"synType\">char<\/span> type, <span class=\"synType\">int<\/span> <span class=\"synStatement\">value<\/span>);\u000a    <span class=\"synType\">public<\/span> Argument(<span class=\"synType\">char<\/span> type, <span class=\"synType\">string<\/span> name);\u000a    <span class=\"synType\">public<\/span> Argument(<span class=\"synType\">char<\/span> type, <span class=\"synType\">string<\/span> name, <span class=\"synType\">bool<\/span> <span class=\"synStatement\">value<\/span>);\u000a    <span class=\"synType\">public<\/span> Argument(<span class=\"synType\">char<\/span> type, <span class=\"synType\">string<\/span> name, <span class=\"synType\">int<\/span> <span class=\"synStatement\">value<\/span>);\u000a    <span class=\"synType\">public<\/span> Argument(<span class=\"synType\">char<\/span> type, <span class=\"synType\">string<\/span> name, <span class=\"synType\">string<\/span> <span class=\"synStatement\">value<\/span>);\u000a    <span class=\"synType\">public<\/span> Argument(<span class=\"synType\">char<\/span> type, <span class=\"synType\">string<\/span> name, <span class=\"synType\">string<\/span> <span class=\"synStatement\">value<\/span>, <span class=\"synType\">bool<\/span> literal);\u000a}\u000a<\/pre>\u000a\u000a\u000a<p>Ghostscript の引数一覧は <a href=\"https:\/\/www.ghostscript.com\/doc\/current\/Use.htm\">How to Use Ghostscript<\/a> および、そのリンク先で確認する事ができます。<\/p>\u000a\u000a<pre class=\"code\" data-lang=\"\" data-unlink>-dAutoRotatePages=\/PageByPage<\/pre>\u000a\u000a\u000a<p>例えば、上記のような Ghostscript 引数を生成する場合、以下のようにコンストラクタの各引数を指定して Argument オブジェクトを生成します。<\/p>\u000a\u000a<pre class=\"code\" data-lang=\"\" data-unlink>new Argument(&#39;d&#39;, &#34;AutoRotatePages&#34;, &#34;PageByPage&#34;, true);<\/pre>\u000a\u000a\u000a<p>最後の引数は、値に \"\/\" （スラッシュ）が必要な場合は true、それ以外は false を指定します。尚、ほとんどの場合、上記以外のコンストラクタを利用する事で、自ら \"\/\" の有無を判定しなくても良いように設計しています。<\/p>\u000a\u000a<h4 id=\"その他の注意事項\">その他の注意事項<\/h4>\u000a\u000a<p>Ghostscript の引数は基本的に日本語などのマルチバイト文字を指定する事はできないようです。そのため、Invoke メソッドに指定する引数には ASCII のみで指定するようにして下さい。<\/p>\u000a\u000a<p>また、マルチバイト文字におけるもう一つの問題は一時フォルダです。Ghostscript は作業フォルダとして TEMP 環境変数の値を利用しますが、Windows のユーザ名に日本語が混在していると問題になる事があります。この問題を回避するために、Converter クラスには Temp と言うプロパティを設定しています。Converter クラスは、このプロパティに値が設定されている場合、Invoke メソッドの実行中のみ TEMP 環境変数を設定された値に変更します。<\/p>\u000a<div class=\"footnote\">\u000a<p class=\"footnote\"><a href=\"#fn-2d887ec3\" name=\"f-2d887ec3\" class=\"footnote-number\">*1<\/a><span class=\"footnote-delimiter\">:<\/span><span class=\"footnote-text\">コマンドラインの引数をそのまま指定するせいか、最初の引数は無視されます<\/span><\/p>\u000a<\/div>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20181126\/cubepdf-ghostscript","PublishTime":"\/Date(1571033375000+0900)\/","Status":1,"Summary":"先日、7-Zip ライブラリとしての CubeICE と言う記事を公開しましたが、ライブラリ化の試みは CubePDF シリーズでも行っています。CubePDF シリーズは Cube.Pdf と言うリポジトリで管理しており、ライブラリ部分は Libraries に、最終的なアプリケーション部分は Applications に配置しています。この記事では、CubePDF ライブラリの内 Ghosts","Title":"Ghostscript を C# から利用するためのライブラリ"},{"Categories":[],"Content":"<p>現在、<a href=\"https:\/\/github.com\/cube-soft\">cube-soft@GitHub<\/a> には <a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\">CubePDF<\/a> や <a href=\"https:\/\/www.cube-soft.jp\/cubeice\/\">CubeICE<\/a> 等の実装コードを始めとして様々なリポジトリが存在します。この記事では、これらのリポジトリを修正する際の基本的な情報について記載します。<\/p>\u000a\u000a<ul class=\"table-of-contents\">\u000a    <li><a href=\"#ディレクトリ構成\">ディレクトリ構成<\/a><\/li>\u000a    <li><a href=\"#Git-ブランチ構成\">Git ブランチ構成<\/a><\/li>\u000a    <li><a href=\"#ビルドテスト方法\">ビルド&amp;テスト方法<\/a><\/li>\u000a<\/ul>\u000a\u000a<h4 id=\"ディレクトリ構成\">ディレクトリ構成<\/h4>\u000a\u000a<pre class=\"code\" data-lang=\"\" data-unlink>&lt;WorkDirectory&gt;\u000a  + Cube.Core\u000a  + Cube.FileSystem\u000a  + Cube.FileSystem.SevenZip\u000a  + Cube.Forms\u000a  + Cube.Images\u000a  + Cube.Net\u000a  + Cube.Pdf\u000a  + Cube.Xui\u000a  + packages\u000a  + resources\u000a    + native\u000a      + x86\u000a      + x64<\/pre>\u000a\u000a\u000a<p>Cube プロジェクトの各リポジトリは、ローカル環境において上記のように配置されている事を想定しています。ただし、Cube.* ディレクトリに関しては異なるリポジトリ間では NuGet パッケージ経由で参照設定を行っているので、必要な（修正したい）リポジトリのみが配置されていれば問題ありません。<\/p>\u000a\u000a<p>packages ディレクトリには NuGet で取得したパッケージ、resources ディレクトリにはそれ以外のライブラリを配置します。packages ディレクトリに関しては、nuget コマンドまたは Visual Studio 経由でパッケージの復元を実行すれば自動的に配置されるため、特に気にする必要はありません。resources ディレクトリには、native と言うサブディレクトリを作成し、そこにアンマネージド・ライブラリを x86\/x64 別に配置します。現在、Cube プロジェクトで利用しているアンマネージド・ライブラリは以下の 2 種類です。<\/p>\u000a\u000a<table>\u000a<thead>\u000a<tr>\u000a<th>リポジトリ<\/th>\u000a<th>ライブラリ<\/th>\u000a<th>ディレクトリ<\/th>\u000a<\/tr>\u000a<\/thead>\u000a<tbody>\u000a<tr>\u000a<td><a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\">Cube.Pdf<\/a><\/td>\u000a<td><a href=\"https:\/\/www.ghostscript.com\/\">Ghostscript<\/a><\/td>\u000a<td>gs<\/td>\u000a<\/tr>\u000a<tr>\u000a<td><a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem.SevenZip\">Cube.FileSystem.SevenZip<\/a><\/td>\u000a<td><a href=\"https:\/\/www.7-zip.org\/\">7-Zip<\/a><\/td>\u000a<td>7z<\/td>\u000a<\/tr>\u000a<\/tbody>\u000a<\/table>\u000a\u000a\u000a<p>これらのライブラリは必ずしもここに配置する必要はありませんが（最終的な実行ディレクトリに存在しておけば良い）、後述する Rakefile との兼ね合い、および Continuous Integration (CI) 環境である AppVeyor とディレクトリ配置を統一する意味で、このディレクトリ構成としています。尚、Cube プロジェクトで使用しているアンマネージド・ライブラリは <a href=\"https:\/\/github.com\/cube-soft\">cube-soft@GitHub<\/a> 内の各種 GitHub Releases からもダウンロード可能です。詳細については、下記を参照下さい。<\/p>\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/clown.hatenablog.jp\/entry\/20181129\/cubepdf-and-ghostscript\">CubePDF に含まれる Ghostscript を手動で更新する方法<\/a><\/li>\u000a<li><a href=\"https:\/\/clown.hatenablog.jp\/entry\/20180524\/cubeice-and-7zip\">CubeICE に含まれる 7-Zip を手動で更新する方法<\/a><\/li>\u000a<\/ul>\u000a\u000a\u000a<h4 id=\"Git-ブランチ構成\">Git ブランチ構成<\/h4>\u000a\u000a<p>Cube プロジェクトには、master, stable, net35 と言う 3 種類のブランチが存在します。この中で、特に何もしなくてもビルド可能なブランチは <strong>stable<\/strong> ブランチとなります。そのため、通常は stable ブランチを起点にすると楽です。net35 ブランチは、stable ブランチと同等の内容を .NET Framework 3.5 ターゲットでビルド可能にしたものなので、必要な場合以外は無視して構いません。<\/p>\u000a\u000a<p>master ブランチは、開発中のものまで含めた最新の状態であるため、NuGet でまだ公開されていないバージョンを参照する事があります。リポジトリ直下に配置している NuGet.config に開発中の NuGet パッケージを取得するための URL を記述しているため、master ブランチでも問題なくビルドできるとは思いますが、予期せぬ不都合が発生する可能性もあります。また、参照されている NuGet パッケージ自体にも、該当バージョンが NuGet パッケージとして公開されるまでに度々、修正が行われます。ビルドに失敗する等の問題が発生した場合は rake clean コマンドを実行するか、packages ディレクトリにある各種 cube.* ディレクトリを手動で削除して下さい。<\/p>\u000a\u000a<h4 id=\"ビルドテスト方法\">ビルド&amp;テスト方法<\/h4>\u000a\u000a<p>ビルドは Visual Studio を起動して「ビルド」メニューを選択すれば、特に難しい点はないかと思います。テストフレームワークとして <a href=\"https:\/\/nunit.org\/\">NUnit<\/a> を使用しているので、Visual Studio 上でユニットテストを実行する場合は拡張機能から <a href=\"https:\/\/marketplace.visualstudio.com\/items?itemName=NUnitDevelopers.NUnit3TestAdapter\">NUnit3 Test Adapter<\/a> を選択してインストールして下さい。<\/p>\u000a\u000a<p>コマンドライン上からの各種実行に関しては Rakefile に記述しているため、Ruby および Rake の実行環境が必要となります。Rakefile に記述しているタスクは clean, build, copy, pack, test の 6 種類で（copy は存在しない場合もある）、デフォルトでは test 以外のタスクが順に実行されます。clean は対象オブジェクトを消去し、build はその名の通りビルドを実行、pack は NuGet パッケージの作成用タスクです。尚、これらのタスク実行中には stable ブランチと net35 ブランチを何度か切り替えるので注意して下さい。<\/p>\u000a\u000a<p>copy タスクは、必要なアンマネージド・ライブラリを bin 下の各ディレクトリにコピーします。この時、コピー元のファイル群は resources\/native に存在する事を想定しているので、それらのファイルは該当ディレクトリに配置して下さい。また、Architecture (x86, x64, AnyCPU), Configuration (Debug, Release), Branch (stable, net35) 毎に出力ディレクトリが異なるので、最終的に 12 種類のディレクトリにコピーされます。<\/p>\u000a\u000a<p>test タスクは、現在のブランチを対象にして、ビルドと NUnit によるテストを実行します。これ以外のタスクは、現在のブランチが何かに関わらず stable, net35 の 2 種類のブランチを対象とするので、このタスクのみ特殊となります。尚、ユニットテストは、ローカル環境における開発中は Visual Studio の GUI で確認する事が多いので、現状では net35 ブランチのテスト結果確認用と言う意味合いが強くなっています（Visual Studio の該当機能が .NET Framework 3.5 非対応となったため）。<\/p>\u000a\u000a<p>その他、AppVeyor における CI 実行内容はリポジトリ毎に存在する AppVeyor.yml に記述しているので、こちらも何かの理解に役立つかもしれません。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20190219\/cube","PublishTime":"\/Date(1571033342000+0900)\/","Status":2,"Summary":"現在、cube-soft@GitHub には CubePDF や CubeICE 等の実装コードを始めとして様々なリポジトリが存在します。この記事では、これらのリポジトリを修正する際の基本的な情報について記載します。 ディレクトリ構成 Git ブランチ構成 ビルド&テスト方法 ディレクトリ構成  + Cube.Core + Cube.FileSystem + Cube.FileSystem.Sev","Title":"Cube のプロジェクト構成およびビルド&テスト方法"},{"Categories":[],"Content":"<p><a href=\"https:\/\/github.com\/cube-soft\">CubeSoft<\/a> の各種プロジェクトでは、継続的インテグレーション (CI: Continuous Integration) 用サービスとして <a href=\"https:\/\/www.appveyor.com\/\">AppVeyor<\/a> を利用していますが、諸々の事情を考慮して <a href=\"https:\/\/azure.microsoft.com\/ja-jp\/services\/devops\/pipelines\/\">Azure Pipelines<\/a> でも同等の CI を実行できるように環境の整備を進めています。この記事では、Azure Pipelines での CI、特に OpenCover\/NUnit を用いてユニットテストを実行し、結果を <a href=\"https:\/\/codecov.io\/gh\/cube-soft\">Codecov<\/a> に送信するまでの手順について記述します。<\/p>\u000a\u000a<ul class=\"table-of-contents\">\u000a    <li><a href=\"#概要\">概要<\/a><\/li>\u000a    <li><a href=\"#備考\">備考<\/a><ul>\u000a            <li><a href=\"#NuGet-task-を利用した-Restore\">NuGet task を利用した Restore<\/a><\/li>\u000a            <li><a href=\"#GitHub-Releases-からダウンロード\">GitHub Releases からダウンロード<\/a><\/li>\u000a            <li><a href=\"#Pipeline-Artifacts-の設定\">Pipeline Artifacts の設定<\/a><\/li>\u000a        <\/ul>\u000a    <\/li>\u000a<\/ul>\u000a\u000a<h4 id=\"概要\">概要<\/h4>\u000a\u000a<p>前提として、何らかの csproj （多くの場合、ユニットテスト用のプロジェクト）に対して下記の PackageReference が記述されている事とします。<\/p>\u000a\u000a<pre class=\"code lang-xml\" data-lang=\"xml\" data-unlink><span class=\"synIdentifier\">&lt;ItemGroup&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;PackageReference <\/span><span class=\"synType\">Include<\/span>=<span class=\"synConstant\">&quot;NUnit&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">Version<\/span>=<span class=\"synConstant\">&quot;3.11.0&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;PackageReference <\/span><span class=\"synType\">Include<\/span>=<span class=\"synConstant\">&quot;NUnit.ConsoleRunner&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">Version<\/span>=<span class=\"synConstant\">&quot;3.10.0&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;PackageReference <\/span><span class=\"synType\">Include<\/span>=<span class=\"synConstant\">&quot;OpenCover&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">Version<\/span>=<span class=\"synConstant\">&quot;4.7.922&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a<span class=\"synIdentifier\">&lt;\/ItemGroup&gt;<\/span>\u000a<\/pre>\u000a\u000a\u000a<p>この状態で、下記のタスクを実行するように YAML ファイルを編集していきます。<\/p>\u000a\u000a<ol>\u000a<li>NuGet Resotre<\/li>\u000a<li>Build<\/li>\u000a<li>Run OpenCover with NUnit<\/li>\u000a<li>Send to Codecov<\/li>\u000a<li>Publish test results<\/li>\u000a<li>NuGet Pack<\/li>\u000a<li>Publish pipline artifacts<\/li>\u000a<\/ol>\u000a\u000a\u000a<p>ここでは、ユニットテストに関係のある 3. ～ 5. の記述を抜粋します。下記を含む全ての記述内容は <a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem\/blob\/master\/AzurePipelines.yml\">AzurePipelines.yml<\/a> を参照下さい。<a href=\"#f-67af27da\" name=\"fn-67af27da\" title=\"Cube プロジェクトでは、取得した各種 NuGet パッケージを &quot;..\/packages&quot; に配置するように設定しています（参考：Cube のプロジェクト構成およびビルド&amp;テスト方法）。初期設定では、これらの NuGet パッケージは &quot;$(UserProfile)\/.nuget\/packages&quot; に配置されるようなので、もしリンク先の YAML ファイルを利用する場合には、適当に置き換えて下さい。\">*1<\/a><\/p>\u000a\u000a<pre class=\"code lang-yaml\" data-lang=\"yaml\" data-unlink><span class=\"synStatement\">- <\/span><span class=\"synIdentifier\">script<\/span><span class=\"synSpecial\">:<\/span> &gt;\u000a    <span class=\"synConstant\">&quot;$(TEST_TOOL)&quot;<\/span>\u000a    -log:Error\u000a    -register:user\u000a    -target:&quot;$(TEST_CORETOOL)&quot;\u000a    -targetargs:&quot;$(PROJECT_NAME).Tests.dll&quot;\u000a    -targetdir:&quot;Tests\\$(PROJECT_BIN)&quot;\u000a    -returntargetcode\u000a    -hideskipped:All\u000a    -output:&quot;$(TEST_COVERAGE)&quot;\u000a    -filter:&quot;$(TEST_FILTERS)&quot;\u000a  <span class=\"synIdentifier\">displayName<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'Run tests via OpenCover and NUnit'<\/span>\u000a\u000a<span class=\"synStatement\">- <\/span><span class=\"synIdentifier\">script<\/span><span class=\"synSpecial\">:<\/span> |\u000a    pip install codecov\u000a    codecov -f <span class=\"synConstant\">&quot;$(TEST_COVERAGE)&quot;<\/span> -t $(CODECOV_TOKEN)\u000a  <span class=\"synIdentifier\">displayName<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'Send coverage results to Codecov'<\/span>\u000a\u000a<span class=\"synStatement\">- <\/span><span class=\"synIdentifier\">task<\/span><span class=\"synSpecial\">:<\/span> PublishTestResults@2\u000a  <span class=\"synIdentifier\">inputs<\/span><span class=\"synSpecial\">:<\/span>\u000a    <span class=\"synIdentifier\">testResultsFormat<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'NUnit'<\/span>\u000a    <span class=\"synIdentifier\">testResultsFiles<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'**\\$(TEST_RESULT)'<\/span>\u000a  <span class=\"synIdentifier\">displayName<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'Publish test results'<\/span>\u000a<\/pre>\u000a\u000a\u000a<p>最初の task (script) で OpenCover を実行し、次の task で Codecov に結果を送信します。尚、この記事の執筆時点では、Azure Pipelines から Codecov に結果を送信するためにはトークンを指定する必要があります。そのため、<a href=\"https:\/\/medium.com\/@stef.heyenrath\/how-to-integrate-codecov-io-in-an-azure-build-pipeline-f1de66c28f4b\">How to integrate codecov.io in an Azure Build Pipeline<\/a> を参考にして、あらかじめ CODECOV_TOKEN と言う環境変数を作成し、必要な値を Secret 設定で追加しておいて下さい。<\/p>\u000a\u000a<p><a href=\"https:\/\/dev.azure.com\/cube-soft-jp\/Cube.FileSystem\/_build\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20190327\/20190327154620.png\" alt=\"Azure Pipelines の環境変数\" \/><\/a><\/p>\u000a\u000a<p>最後の task で Azure Pipelines 上にテスト結果を送信します。PublishTestResults タスクを実行すると、各ビルドの Tests タブに結果が表示されるようになります。<\/p>\u000a\u000a<p><a href=\"https:\/\/dev.azure.com\/cube-soft-jp\/Cube.FileSystem\/_build\/results?buildId=77&amp;view=ms.vss-test-web.build-test-results-tab\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20190327\/20190327150101.png\" alt=\"Azure Pipelines 上でのテスト結果\" \/><\/a><\/p>\u000a\u000a<h4 id=\"備考\">備考<\/h4>\u000a\u000a<p>これ以降は、今回 Azure Pipelines 上で CI 環境を整えるにおいて、嵌まったポイント等いくつかの関連事項を記述します。<\/p>\u000a\u000a<h5 id=\"NuGet-task-を利用した-Restore\">NuGet task を利用した Restore<\/h5>\u000a\u000a<p>NuGet に関連するコマンドは <a href=\"https:\/\/docs.microsoft.com\/en-us\/azure\/devops\/pipelines\/tasks\/package\/nuget?view=azure-devops\">NuGet task<\/a> が用意されており、Restore に関しても通常はこの task を利用します。<\/p>\u000a\u000a<pre class=\"code lang-yaml\" data-lang=\"yaml\" data-unlink><span class=\"synStatement\">- <\/span><span class=\"synIdentifier\">task<\/span><span class=\"synSpecial\">:<\/span> NuGetCommand@2\u000a  <span class=\"synIdentifier\">inputs<\/span><span class=\"synSpecial\">:<\/span>\u000a    <span class=\"synIdentifier\">command<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'restore'<\/span>\u000a    <span class=\"synIdentifier\">restoreSolution<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'$(PROJECT_NAME).sln'<\/span>\u000a   <span class=\"synComment\"> #feedsToUse: 'config'<\/span>\u000a   <span class=\"synComment\"> #nugetConfigPath: 'NuGet.config'<\/span>\u000a  <span class=\"synIdentifier\">displayName<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'Restore NuGet packages'<\/span>\u000a<\/pre>\u000a\u000a\u000a<p>しかし、NuGetCommand@2 経由で実行した場合、初期設定ではカレントディレクトリに存在する NuGet.config は無視されます。config ファイルを反映させるには feedsToUse および nugetConfigPath 引数を利用するようなのですが、実際に試した所、今度は api.nuget.org が Source として認識しないような挙動を示しました。恐らく、明示的に config を指定した場合、この辺りも含めて設定する必要があるものと予想されます。<\/p>\u000a\u000a<pre class=\"code lang-yaml\" data-lang=\"yaml\" data-unlink><span class=\"synStatement\">- <\/span><span class=\"synIdentifier\">script<\/span><span class=\"synSpecial\">:<\/span> |\u000a    nuget restore <span class=\"synConstant\">&quot;$(PROJECT_NAME).sln&quot;<\/span>\u000a  <span class=\"synIdentifier\">displayName<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'Restore NuGet packages'<\/span>\u000a<\/pre>\u000a\u000a\u000a<p>以上を考慮すると、NuGet.config を用意している場合、現時点では上記のように script で実行する方が楽なようです。<\/p>\u000a\u000a<h5 id=\"GitHub-Releases-からダウンロード\">GitHub Releases からダウンロード<\/h5>\u000a\u000a<p>依存するライブラリが全て NuGet パッケージとして取得できれば良いのですが、必ずしもそうではない場合もあります。例えば、<a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem.SevenZip\">CubeICE<\/a> は 7z.dll と言うライブラリに依存しています。ここでは、このライブラリを <a href=\"https:\/\/github.com\/cube-soft\/7z\/releases\">Releases - cube-soft\/7z<\/a> から取得する事を試みます。<\/p>\u000a\u000a<pre class=\"code lang-yaml\" data-lang=\"yaml\" data-unlink><span class=\"synStatement\">- <\/span><span class=\"synIdentifier\">task<\/span><span class=\"synSpecial\">:<\/span> DownloadGitHubRelease@0\u000a  <span class=\"synIdentifier\">inputs<\/span><span class=\"synSpecial\">:<\/span>\u000a    <span class=\"synIdentifier\">connection<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'cube-soft-ci'<\/span>\u000a    <span class=\"synIdentifier\">userRepository<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'cube-soft\/7z'<\/span>\u000a    <span class=\"synIdentifier\">itemPattern<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'7z-*-x64.zip'<\/span>\u000a    <span class=\"synIdentifier\">downloadPath<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'$(Build.SourcesDirectory)'<\/span>\u000a  <span class=\"synIdentifier\">displayName<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'Download 7-Zip modules'<\/span>\u000a<\/pre>\u000a\u000a\u000a<p>GitHub Releases からのダウンロードには <a href=\"https:\/\/docs.microsoft.com\/en-us\/azure\/devops\/pipelines\/tasks\/utility\/download-github-release?view=azure-devops\">Download GitHub Release task<\/a> を利用します。userRepository に対象となるリポジトリの名前、itemPattern にダウンロードするファイルを表す文字列、downloadPath に保存ディレクトリのパスを指定します。<\/p>\u000a\u000a<p>connection には、<a href=\"https:\/\/docs.microsoft.com\/en-us\/azure\/devops\/pipelines\/library\/service-endpoints?view=azure-devops\">Service connections<\/a> と呼ばれる機能で作成した文字列を記述します。作成手順は、まず <a href=\"https:\/\/help.github.com\/en\/articles\/creating-a-personal-access-token-for-the-command-line\">Creating a personal access token for the command line<\/a> を参考に、GitHub 上でトークンを生成します（生成時に指定するスコープに関しては、repo, user, admin:repo_hook が推奨されているようです）。次に、Azure Pipelines の左下にある Project settings から Service connections を選択し、New service connection で GitHub を選択します。<\/p>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20190327\/20190327164113.png\" alt=\"Service connection の新規作成\" \/><\/p>\u000a\u000a<p>新規作成画面で Personal access token を選択し、Connection Name には適当な名前、Token には GitHub で取得したトークンを入力します。最後に、ここで設定した名前を DownloadGitHubRelease@0 の connection 引数に記述すると完了です。<\/p>\u000a\u000a<h5 id=\"Pipeline-Artifacts-の設定\">Pipeline Artifacts の設定<\/h5>\u000a\u000a<p>Azure Pipelines には Artifacts と言う項目が存在します。これは、Azure DevOps の Artifacts（左側にメニューとして表示されている項目）とは別物で、各ビルド結果の右上に表示されるリンクから辿る事ができます。<\/p>\u000a\u000a<p><a href=\"https:\/\/dev.azure.com\/cube-soft-jp\/Cube.FileSystem\/_build\/results?buildId=79\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20190327\/20190327165228.png\" alt=\"Pipeline Artifacts\" \/><\/a><\/p>\u000a\u000a<p>この Artifacts に成果物を表示するには、<a href=\"https:\/\/docs.microsoft.com\/en-us\/azure\/devops\/pipelines\/tasks\/utility\/publish-pipeline-artifact?view=azure-devops\">Publish Pipeline Artifact task<\/a> を利用します。<\/p>\u000a\u000a<pre class=\"code lang-yaml\" data-lang=\"yaml\" data-unlink><span class=\"synStatement\">- <\/span><span class=\"synIdentifier\">task<\/span><span class=\"synSpecial\">:<\/span> PublishPipelineArtifact@0\u000a  <span class=\"synIdentifier\">inputs<\/span><span class=\"synSpecial\">:<\/span>\u000a    <span class=\"synIdentifier\">artifactName<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'$(PROJECT_NAME)'<\/span>\u000a    <span class=\"synIdentifier\">targetPath<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'$(Build.ArtifactStagingDirectory)'<\/span>\u000a  <span class=\"synIdentifier\">displayName<\/span><span class=\"synSpecial\">:<\/span> <span class=\"synConstant\">'Publish pipline artifacts'<\/span>\u000a<\/pre>\u000a\u000a\u000a<p>NuGet Pack など多くの task において、実行結果は $(Build.ArtifactStagingDirectory) に保存されます。そのため、targetPath 引数にはこの変数を指定しておくと良いようです。<\/p>\u000a<div class=\"footnote\">\u000a<p class=\"footnote\"><a href=\"#fn-67af27da\" name=\"f-67af27da\" class=\"footnote-number\">*1<\/a><span class=\"footnote-delimiter\">:<\/span><span class=\"footnote-text\">Cube プロジェクトでは、取得した各種 NuGet パッケージを &quot;..\/packages&quot; に配置するように設定しています（参考：<a href=\"https:\/\/clown.hatenablog.jp\/entry\/20190219\/cube\">Cube のプロジェクト構成およびビルド&amp;テスト方法<\/a>）。初期設定では、これらの NuGet パッケージは &quot;$(UserProfile)\/.nuget\/packages&quot; に配置されるようなので、もしリンク先の YAML ファイルを利用する場合には、適当に置き換えて下さい。<\/span><\/p>\u000a<\/div>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20190327\/azure-pipelines","PublishTime":"\/Date(1570900951000+0900)\/","Status":2,"Summary":"CubeSoft の各種プロジェクトでは、継続的インテグレーション (CI: Continuous Integration) 用サービスとして AppVeyor を利用していますが、諸々の事情を考慮して Azure Pipelines でも同等の CI を実行できるように環境の整備を進めています。この記事では、Azure Pipelines での CI、特に OpenCover\/NUnit を用い","Title":"Azure Pipelines で OpenCover\/NUnit を実行し Codecov に送信"},{"Categories":[],"Content":"<p>2019 年 4 月 2 日、<a href=\"https:\/\/visualstudio.microsoft.com\/downloads\/\">Visual Studio 2019<\/a> が正式版としてリリース (GA: General Available) されました。この記事では、 Visual Studio 2019 に関連する内容として、C# の新しいプロジェクト形式 (csproj) への移行について記載します。新 csproj 自体は Visual Studio 2017 の頃から利用可能でしたが、WinForms や WPF などのプロジェクトに対する Visual Studio 側の対応も 2019 で進んだようなので、移行するには良いタイミングではないでしょうか。<\/p>\u000a\u000a<ul class=\"table-of-contents\">\u000a    <li><a href=\"#新-csproj-の基本的な構成\">新 csproj の基本的な構成<\/a><ul>\u000a            <li><a href=\"#既定の-Include-に関する設定\">既定の Include に関する設定<\/a><\/li>\u000a            <li><a href=\"#NuGet-パッケージに関する設定\">NuGet パッケージに関する設定<\/a><\/li>\u000a            <li><a href=\"#AnyCPU-に関する設定\">AnyCPU に関する設定<\/a><\/li>\u000a            <li><a href=\"#PropertiesResources-に関する設定\">Properties.Resources に関する設定<\/a><\/li>\u000a            <li><a href=\"#参照に関する設定\">参照に関する設定<\/a><\/li>\u000a            <li><a href=\"#削除するファイル一覧\">削除するファイル一覧<\/a><\/li>\u000a        <\/ul>\u000a    <\/li>\u000a    <li><a href=\"#WinForms\">WinForms<\/a><ul>\u000a            <li><a href=\"#基本的な構成\">基本的な構成<\/a><\/li>\u000a            <li><a href=\"#MicrosoftNETSdkWindowsDesktop-に関して\">Microsoft.NET.Sdk.WindowsDesktop に関して<\/a><\/li>\u000a            <li><a href=\"#Include-および-Update-規則\">Include および Update 規則<\/a><\/li>\u000a        <\/ul>\u000a    <\/li>\u000a    <li><a href=\"#WPF\">WPF<\/a><ul>\u000a            <li><a href=\"#基本的な構成-1\">基本的な構成<\/a><\/li>\u000a            <li><a href=\"#Include-および-Update-規則-1\">Include および Update 規則<\/a><\/li>\u000a        <\/ul>\u000a    <\/li>\u000a    <li><a href=\"#新-csproj-具体例へのリンク一覧\">新 csproj 具体例へのリンク一覧<\/a><\/li>\u000a<\/ul>\u000a\u000a<h4 id=\"新-csproj-の基本的な構成\">新 csproj の基本的な構成<\/h4>\u000a\u000a<p>新しい csproj 形式では、システム側が既定値を設ける事により、多くの項目が省略可能となりました。これは、Visual Studio による自動生成・更新を前提にした複雑なものから、手動による更新も想定した簡素なものへの転換と言う感じで、特にバージョン管理などの観点から見ると非常に楽になったように思います。<\/p>\u000a\u000a<p>以下に、新 csproj において省略しない方が良い（多くの場合、初期設定とは異なる）ものを記述します。<\/p>\u000a\u000a<pre class=\"code lang-xml\" data-lang=\"xml\" data-unlink><span class=\"synIdentifier\">&lt;Project <\/span><span class=\"synType\">Sdk<\/span>=<span class=\"synConstant\">&quot;Microsoft.NET.Sdk&quot;<\/span><span class=\"synIdentifier\">&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;PropertyGroup&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;TargetFramework&gt;<\/span>net45<span class=\"synIdentifier\">&lt;\/TargetFramework&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;LangVersion&gt;<\/span>latest<span class=\"synIdentifier\">&lt;\/LangVersion&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;Platforms&gt;<\/span>AnyCPU;x86;x64<span class=\"synIdentifier\">&lt;\/Platforms&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;Optimize&gt;<\/span>true<span class=\"synIdentifier\">&lt;\/Optimize&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;EnableDefaultNoneItems&gt;<\/span>false<span class=\"synIdentifier\">&lt;\/EnableDefaultNoneItems&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;GenerateDocumentationFile&gt;<\/span>true<span class=\"synIdentifier\">&lt;\/GenerateDocumentationFile&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;DefineConstants <\/span><span class=\"synType\">Condition<\/span>=<span class=\"synConstant\">&quot; '$(Configuration)' == 'Debug' &quot;<\/span><span class=\"synIdentifier\">&gt;<\/span>DEBUG;TRACE<span class=\"synIdentifier\">&lt;\/DefineConstants&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;\/PropertyGroup&gt;<\/span>\u000a<span class=\"synIdentifier\">&lt;\/Project&gt;<\/span>\u000a<\/pre>\u000a\u000a\u000a<p><strong>TargetFramework<\/strong> には net45, netcoreapp3.0, netstandard2.0 などの文字列を指定します（参考：<a href=\"https:\/\/docs.microsoft.com\/ja-jp\/nuget\/reference\/target-frameworks\">Target Frameworks Reference for NuGet<\/a>）。この項目は、旧 csproj の TargetFrameworkVersion から置き換わったものです。また、新 csproj 形式では TargetFrameworks（複数形）を代わりに用いる事で、複数の TargetFramework を &quot;;&quot; (semicolon) で区切って列挙する事もできるようです。<\/p>\u000a\u000a<p><strong>LangVersion<\/strong> には C# のバージョンを指定します（参考：<a href=\"https:\/\/docs.microsoft.com\/ja-jp\/dotnet\/csharp\/language-reference\/configure-language-version\">Select the C# language version<\/a>）。具体的なバージョン番号を指定する事もできますが、多くの場合においては、latest または latestMajor のどちらかだと思います。Visual Studio 2019 においては LangVersion の初期設定は latest なので、この項目は省略しても問題ありません。ただ、<a href=\"https:\/\/www.appveyor.com\/\">AppVeyor<\/a> 等で継続的インテグレーション (CI: Continuous Integration) を実行する際に意図しない挙動をいくつか確認したため、明記する事にしています。<\/p>\u000a\u000a<p><strong>Platforms<\/strong> は Visual Studio 上で x86 や x64 を選択可能にしたい時に明記します。C#\/.NET では多くの場合において AnyCPU で良いと思いますが、Unmanaged なライブラリとの兼ね合いでプラットフォームを固定したい場合などに設定します。<\/p>\u000a\u000a<p><strong>GenerateDocumentationFile<\/strong> は、<a href=\"https:\/\/docs.microsoft.com\/ja-jp\/dotnet\/csharp\/programming-guide\/xmldoc\/xml-documentation-comments\">XML Documentation Comments<\/a> に従って記述されたコメントに基づいて XML ファイルを生成するかどうかを決定します。尚、XML ファイル自体は後述する DocumentationFile に出力パスを記述すれば、この項目がなくても生成されます。しかし、その場合には生成された XML ファイルが NuGet パッケージ (*.nupkg) に含まれないようです。NuGet パッケージにも含める場合、この項目を true で明記する必要があります。<\/p>\u000a\u000a<p><strong>DefineConstants<\/strong> は必要なシンボルを記述するための項目ですが、省略時には TRACE のみが設定されるようです。多くの場合、Debug モード時には TRACE に加えて DEBUG シンボルの存在も想定されているので、それを明記しています。<\/p>\u000a\u000a<h5 id=\"既定の-Include-に関する設定\">既定の Include に関する設定<\/h5>\u000a\u000a<p>新 csproj では、ソースファイル等に関する記述をできるだけ省略可能にするために、既定では以下の規則で自動的に Include される事になっています（参考：<a href=\"https:\/\/docs.microsoft.com\/en-us\/dotnet\/core\/tools\/csproj#default-compilation-includes-in-net-core-projects\">Default compilation includes in .NET Core projects<\/a>）。<\/p>\u000a\u000a<table>\u000a<thead>\u000a<tr>\u000a<th>Element<\/th>\u000a<th>Include<\/th>\u000a<th>Remove<\/th>\u000a<\/tr>\u000a<\/thead>\u000a<tbody>\u000a<tr>\u000a<td>Compile<\/td>\u000a<td>**\/*.cs<\/td>\u000a<td>N\/A<\/td>\u000a<\/tr>\u000a<tr>\u000a<td>EmbeddedResource<\/td>\u000a<td>**\/*.resx<\/td>\u000a<td>N\/A<\/td>\u000a<\/tr>\u000a<tr>\u000a<td>None<\/td>\u000a<td>**\/*<\/td>\u000a<td>**\/*.cs; **\/*.resx<\/td>\u000a<\/tr>\u000a<\/tbody>\u000a<\/table>\u000a\u000a\u000a<p>しかし、これらの Include 規則は邪魔になる事もあるため、無効にする方法もいくつか提供されています。具体的には、上記の全ての規則を無効にするには <strong>EnableDefaultItems<\/strong> を、Compile および None の項目のみを無効にするにはそれぞれ <strong>EnableDefaultCompileItems<\/strong>, <strong>EnableDefaultNoneItems<\/strong> を false で記述します（EnableDefaultEmbeddedResourceItems が存在するかどうかは不明）。<\/p>\u000a\u000a<p>個人的には None の Include 規則には不安に感じる所もあるため、EnableDefaultNoneItems を false に設定した上で自力で明記する事にしています。<\/p>\u000a\u000a<h5 id=\"NuGet-パッケージに関する設定\">NuGet パッケージに関する設定<\/h5>\u000a\u000a<p>新 csproj では、従来 AssemblyInfo.cs および *.nuspec に記述されていた内容が全て csproj に統合されました。生成されるアセンブリのメタ情報、および NuGet パッケージに関する項目は下記の通りです。<\/p>\u000a\u000a<pre class=\"code lang-xml\" data-lang=\"xml\" data-unlink><span class=\"synIdentifier\">&lt;PropertyGroup&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;Version&gt;<\/span>1.0.0<span class=\"synIdentifier\">&lt;\/Version&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;Authors&gt;<\/span>clown;cube-soft<span class=\"synIdentifier\">&lt;\/Authors&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;Company&gt;<\/span>CubeSoft<span class=\"synIdentifier\">&lt;\/Company&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;Description&gt;<\/span>Some description.<span class=\"synIdentifier\">&lt;\/Description&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;Copyright&gt;<\/span>Copyright © 2010 CubeSoft, Inc.<span class=\"synIdentifier\">&lt;\/Copyright&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;PackageTags&gt;<\/span>Ta1;Tag2;Tag3<span class=\"synIdentifier\">&lt;\/PackageTags&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;PackageLicenseExpression&gt;<\/span>Apache-2.0<span class=\"synIdentifier\">&lt;\/PackageLicenseExpression&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;PackageProjectUrl&gt;<\/span>https:\/\/github.com\/cube-soft\/$(AssemblyName)<span class=\"synIdentifier\">&lt;\/PackageProjectUrl&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;PackageIconUrl&gt;<\/span>https:\/\/github.com\/cube-soft\/$(AssemblyName)\/blob\/master\/Icon.png?raw=true<span class=\"synIdentifier\">&lt;\/PackageIconUrl&gt;<\/span>\u000a\u000a  <span class=\"synComment\">&lt;!-- プロジェクト名と異なる場合 --&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;Product&gt;<\/span>Cube.Custom.Product<span class=\"synIdentifier\">&lt;\/Product&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;AssemblyName&gt;<\/span>Cube.Custom.Product<span class=\"synIdentifier\">&lt;\/AssemblyName&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;AssemblyTitle&gt;<\/span>Custom Title<span class=\"synIdentifier\">&lt;\/AssemblyTitle&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;RootNamespace&gt;<\/span>CustomNamespace<span class=\"synIdentifier\">&lt;\/RootNamespace&gt;<\/span>\u000a\u000a  <span class=\"synComment\">&lt;!-- NuGet パッケージの生成可否を明記する場合 --&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;IsPackable&gt;<\/span>true<span class=\"synIdentifier\">&lt;\/IsPackable&gt;<\/span>\u000a\u000a  <span class=\"synComment\">&lt;!-- 厳密な名前付けに関する設定 --&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;SignAssembly&gt;<\/span>true<span class=\"synIdentifier\">&lt;\/SignAssembly&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;AssemblyOriginatorKeyFile&gt;<\/span>Cube.snk<span class=\"synIdentifier\">&lt;\/AssemblyOriginatorKeyFile&gt;<\/span>\u000a<span class=\"synIdentifier\">&lt;\/PropertyGroup&gt;<\/span>\u000a<\/pre>\u000a\u000a\u000a<p><strong>PackageLicenseExpression<\/strong> には、成果物（NuGet パッケージ）に適用するライセンスを指定します。指定可能な文字列に関しては <a href=\"https:\/\/spdx.org\/licenses\/\">SPDX License List<\/a> を参照下さい。これまで、ライセンスは URL で指定していましたが、NuGet の仕様変更により deprecated となったようです。<\/p>\u000a\u000a<p><strong>Product<\/strong>, <strong>AssemblyName<\/strong>, <strong>AssemblyTitle<\/strong>, <strong>RootNamespace<\/strong> の 4 種類は、省略時にはプロジェクト名（csproj 拡張子を除く名前）が設定されます。<\/p>\u000a\u000a<p><strong>IsPackable<\/strong> は、プロジェクトが NuGet パッケージを生成可能かどうかを指定します。既定値は true なので明記する必要性は薄いと思いますが、AppVeyor 等の CI サービスにおいて、自動的に NuGet パッケージを生成して欲しくない時などに false を設定する事があります。<\/p>\u000a\u000a<p><strong>SignAssembly<\/strong> および <strong>AssemblyOriginatorKeyFile<\/strong> は、厳密な名前付けに関する項目です。これらの項目は旧 csproj と同じなので、詳細は省略します。<\/p>\u000a\u000a<h5 id=\"AnyCPU-に関する設定\">AnyCPU に関する設定<\/h5>\u000a\u000a<p>新 csproj は Platform が AnyCPU の場合、初期設定では（例えば）&quot;bin\/Release\/net45&quot; に出力されます（ちなみに、旧 csproj は &quot;bin\/Release&quot;）。<\/p>\u000a\u000a<pre class=\"code lang-xml\" data-lang=\"xml\" data-unlink><span class=\"synIdentifier\">&lt;PropertyGroup <\/span><span class=\"synType\">Condition<\/span>=<span class=\"synConstant\">&quot; '$(Platform)' == 'AnyCPU' &quot;<\/span><span class=\"synIdentifier\">&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;OutputPath&gt;<\/span>bin\\Any CPU\\$(Configuration)\\<span class=\"synIdentifier\">&lt;\/OutputPath&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;DocumentationFile&gt;<\/span>bin\\Any CPU\\$(Configuration)\\$(TargetFramework)\\$(AssemblyName).xml<span class=\"synIdentifier\">&lt;\/DocumentationFile&gt;<\/span>\u000a<span class=\"synIdentifier\">&lt;\/PropertyGroup&gt;<\/span>\u000a<\/pre>\u000a\u000a\u000a<p>多くの場合においては初期設定のままで問題ないと思いますが、AppVeyor 等の CI サービスにおいて意図しない挙動をいくつか確認したため、AnyCPU の OutputPath を上記のように設定しています。尚、新 csproj では OutputPath で設定された文字列に $(TargetFramework) を追加したものが実際の出力パスとなるようです。<\/p>\u000a\u000a<h5 id=\"PropertiesResources-に関する設定\">Properties.Resources に関する設定<\/h5>\u000a\u000a<p>前述した通り、新 csproj において *.resx ファイルは EmbeddedResource として自動的に Include されます。しかし、この状態では Visual Studio 上でのリソース編集が Resources.Designer.cs に反映されません。これを反映させるには、旧 csproj で指定されていた内容を明記する必要があります。<\/p>\u000a\u000a<pre class=\"code lang-xml\" data-lang=\"xml\" data-unlink><span class=\"synIdentifier\">&lt;ItemGroup&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;Compile <\/span><span class=\"synType\">Update<\/span>=<span class=\"synConstant\">&quot;Properties\\Resources.Designer.cs&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">DependentUpon<\/span>=<span class=\"synConstant\">&quot;Resources.resx&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">AutoGen<\/span>=<span class=\"synConstant\">&quot;True&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">DesignTime<\/span>=<span class=\"synConstant\">&quot;True&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;EmbeddedResource <\/span><span class=\"synType\">Update<\/span>=<span class=\"synConstant\">&quot;Properties\\Resources.resx&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">Generator<\/span>=<span class=\"synConstant\">&quot;ResXFileCodeGenerator&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">LastGenOutput<\/span>=<span class=\"synConstant\">&quot;Resources.Designer.cs&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a<span class=\"synIdentifier\">&lt;\/ItemGroup&gt;<\/span>\u000a<\/pre>\u000a\u000a\u000a<p>ここで重要なのは、<strong>Update<\/strong> 属性を使用している点です。*.resx は全て追加済みとなっているため、<strong>Include<\/strong> 属性で明記すると重複エラーとなります。これを回避するには、一つは前述した EnableDefaultItems に false を設定する事、そしてもう一つが Update 属性を使用する事です。<\/p>\u000a\u000a<p>尚、パスの区切り文字を &quot;\/&quot; (slash) にした場合、Visual Studio 上でリソースを編集したタイミングで csproj が自動的に編集されてしまいました（&quot;Properties\/Resources&quot; と &quot;Properties\\Resources&quot; が両方とも記述される）。少なくとも .NET Framework をターゲットにしている場合、もうしばらくは &quot;\\&quot; (backslash) を使用するほうが無難なようです。<\/p>\u000a\u000a<h5 id=\"参照に関する設定\">参照に関する設定<\/h5>\u000a\u000a<p>新 csproj では、参照に関する記述方法も簡素化されています。特に、これまで packages.config と旧 csproj の 2 種類のファイルに記述されていた NuGet パッケージの参照内容が、新 csproj では PackageReference と言う項目に統合されました。<\/p>\u000a\u000a<pre class=\"code lang-xml\" data-lang=\"xml\" data-unlink><span class=\"synIdentifier\">&lt;ItemGroup&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;ProjectReference <\/span><span class=\"synType\">Include<\/span>=<span class=\"synConstant\">&quot;..\\Another\\Another.csproj&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;PackageReference <\/span><span class=\"synType\">Include<\/span>=<span class=\"synConstant\">&quot;SomePackage&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">Version<\/span>=<span class=\"synConstant\">&quot;1.0.0&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;Reference <\/span><span class=\"synType\">Include<\/span>=<span class=\"synConstant\">&quot;System.For.Bar&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a<span class=\"synIdentifier\">&lt;\/ItemGroup&gt;<\/span>\u000a<\/pre>\u000a\u000a\u000a<p>ProjectReference や PackageReference は推移的な参照をサポートしており、ProjectReference の ProjectReference や PackageReference の PackageReference などは自動的に解決してくれます。このため、新 csproj には直近のプロジェクトまたは NuGet パッケージの参照のみを追加すれば OK です。ただし、推移的なプロジェクト参照に関しては、全てのプロジェクトが新 csproj 形式でなければならないそうです（参考：<a href=\"https:\/\/ufcpp.net\/blog\/2017\/5\/newcsproj\/\">新しい csproj 形式<\/a>）。<\/p>\u000a\u000a<h5 id=\"削除するファイル一覧\">削除するファイル一覧<\/h5>\u000a\u000a<p>前述したように、新しい csproj 形式では、これまでいくつかのファイルに分割して記述されていた情報が一つのファイルに統合されました。そのため、以下のファイルは必要な情報を csproj に記述した後に削除する必要があります。<\/p>\u000a\u000a<ul>\u000a<li>**\/Properties\/AssemblyInfo.cs<\/li>\u000a<li>**\/packages.config<\/li>\u000a<li>**\/*.nuspec<\/li>\u000a<\/ul>\u000a\u000a\u000a<h4 id=\"WinForms\">WinForms<\/h4>\u000a\u000a<p>ここからは、WinForms および WPF アプリケーションの新 csproj について説明します。<\/p>\u000a\u000a<h5 id=\"基本的な構成\">基本的な構成<\/h5>\u000a\u000a<p>WinForms の基本的な設定は下記の通りです。尚、これまで記述した内容の多くを省略していますが、それらの設定も必要に応じて追加して下さい。<\/p>\u000a\u000a<pre class=\"code lang-xml\" data-lang=\"xml\" data-unlink><span class=\"synIdentifier\">&lt;Project <\/span><span class=\"synType\">Sdk<\/span>=<span class=\"synConstant\">&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;<\/span><span class=\"synIdentifier\">&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;PropertyGroup&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;OutputType&gt;<\/span>WinExe<span class=\"synIdentifier\">&lt;\/OutputType&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;TargetFramework&gt;<\/span>net45<span class=\"synIdentifier\">&lt;\/TargetFramework&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;UseWindowsForms&gt;<\/span>true<span class=\"synIdentifier\">&lt;\/UseWindowsForms&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;EnableDefaultNoneItems&gt;<\/span>false<span class=\"synIdentifier\">&lt;\/EnableDefaultNoneItems&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;ApplicationIcon&gt;<\/span>App.ico<span class=\"synIdentifier\">&lt;\/ApplicationIcon&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;ApplicationManifest&gt;<\/span>App.manifest<span class=\"synIdentifier\">&lt;\/ApplicationManifest&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;\/PropertyGroup&gt;<\/span>\u000a<span class=\"synIdentifier\">&lt;\/Project&gt;<\/span>\u000a<\/pre>\u000a\u000a\u000a<p>重要な点は、Project の Sdk 属性を <strong>Microsoft.NET.Sdk.WindowsDesktop<\/strong> にする事と、<strong>UseWindowsForms<\/strong> を true で明記する事です（参考：<a href=\"https:\/\/docs.microsoft.com\/ja-jp\/dotnet\/core\/whats-new\/dotnet-core-3-0#windows-desktop\">Windows Desktop<\/a>）。これらの項目の意味については、後述します。<\/p>\u000a\u000a<p><strong>OutputType<\/strong> の規定値は Library のようです。そのため、WinForms や WPF アプリケーションの場合、この項目を WinExe に設定します。<\/p>\u000a\u000a<p><strong>ApplicationIcon<\/strong> および <strong>ApplicationManifest<\/strong> には、アイコン等のファイルを指定します。これらの項目は旧 csproj と同じなので、詳細は省略します。<\/p>\u000a\u000a<h5 id=\"MicrosoftNETSdkWindowsDesktop-に関して\">Microsoft.NET.Sdk.WindowsDesktop に関して<\/h5>\u000a\u000a<p>Visual Studio 2019 かつ .NET Core 3.0 の環境において新たに指定可能となった Microsoft.NET.Sdk.WindowsDesktop および UseWindowsForms ですが、手元の環境で確認した限り、.NET Framework では既定の参照内容に影響を及ぼすようです<a href=\"#f-58da1a60\" name=\"fn-58da1a60\" title=\"尚、TargetFramework を netcoreapp3.0 に設定した場合、現時点では Microsoft.NET.Sdk.WindowsDesktop と記述した時点で UseWindowsForms, UseWPF の設定に関わらず全ての WinForms\/WPF ライブラリが参照に追加されるようです。\">*1<\/a>。以下の図は、UseWindowsForms の設定値と Visual Studio 2019 上で確認できる参照内容の対応関係を表したものになります。<\/p>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20190404\/20190404113751.png\" alt=\"UseWindowsForms の設定による違い\" \/><\/p>\u000a\u000a<p>この図を見ると、UseWindowsForms が true の場合、WinForms ライブラリである System.Windows.Forms が参照に追加されている事が分かります。他に UseWPF と言う項目も存在しますが、true にした場合には同様に PresentationCore 等の WPF に必要なライブラリが参照に追加されます。ただし、これらの項目は Sdk が Microsoft.NET.Sdk.WindowsDesktop の場合のみ有効で、Microsoft.NET.Sdk の場合は無視されます。<\/p>\u000a\u000a<p>注意点として、Visual Studio 2017 では、.NET Core 3.0 SDK の有効・無効に関わらず Microsoft.NET.Sdk.WindowsDesktop を指定したプロジェクトの読み込みに失敗します。また、Visual Studio 2019 であっても .NET Core 3.0 が無効の場合、ビルドに失敗します。したがって、これらの環境との互換性を考慮する場合、Sdk に Microsoft.NET.Sdk を指定した上で各種ライブラリの参照を明記する必要があります。<\/p>\u000a\u000a<h5 id=\"Include-および-Update-規則\">Include および Update 規則<\/h5>\u000a\u000a<p>WinForms におけるソースファイル等の Include および Update 規則に関する記述内容は下記になります。<\/p>\u000a\u000a<pre class=\"code lang-xml\" data-lang=\"xml\" data-unlink><span class=\"synIdentifier\">&lt;ItemGroup&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;Compile <\/span><span class=\"synType\">Update<\/span>=<span class=\"synConstant\">&quot;Views\\**\\*.cs&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">SubType<\/span>=<span class=\"synConstant\">&quot;Form&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;Compile <\/span><span class=\"synType\">Update<\/span>=<span class=\"synConstant\">&quot;Views\\**\\*.Designer.cs&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">SubType<\/span>=<span class=\"synConstant\">&quot;Code&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;EmbeddedResource <\/span><span class=\"synType\">Update<\/span>=<span class=\"synConstant\">&quot;Views\\**\\*.resx&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">DependentUpon<\/span>=<span class=\"synConstant\">&quot;%(Filename).cs&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;None <\/span><span class=\"synType\">Include<\/span>=<span class=\"synConstant\">&quot;Assets\\**\\*&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;None <\/span><span class=\"synType\">Include<\/span>=<span class=\"synConstant\">&quot;App.config&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a<span class=\"synIdentifier\">&lt;\/ItemGroup&gt;<\/span>\u000a<\/pre>\u000a\u000a\u000a<p>この中で最低限必要な項目は EmbeddedResource です。前述したように *.resx は自動的に Include されますが、これだけだと Form にアイコンを設定している場合などで実行時エラーが発生します。これを防止するために WinForms に関連する *.resx に対して、DependentUpon 属性を指定する形で Update します。尚、Include や Update にワイルドカードで指定した場合、&quot;%(Filename)&quot; で各ファイルの拡張子を除いた名前を取得できるようです。<\/p>\u000a\u000a<p>2 種類の Compile 設定は、各種 Form を Visual Studio のデザイナ上で編集可能にするための設定です。ただし、これらの設定は Visual Studio 2017 では効果がありませんでした。<\/p>\u000a\u000a<h4 id=\"WPF\">WPF<\/h4>\u000a\u000a<p>次は、WPF アプリケーションの新 csproj について説明します。<\/p>\u000a\u000a<h5 id=\"基本的な構成-1\">基本的な構成<\/h5>\u000a\u000a<p>WPF の基本的な設定は下記の通りです。UseWindowsForms が UseWPF に置き換わったのみで、それ以外は全て WinForms と同様です。<\/p>\u000a\u000a<pre class=\"code lang-xml\" data-lang=\"xml\" data-unlink><span class=\"synIdentifier\">&lt;Project <\/span><span class=\"synType\">Sdk<\/span>=<span class=\"synConstant\">&quot;Microsoft.NET.Sdk.WindowsDesktop&quot;<\/span><span class=\"synIdentifier\">&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;PropertyGroup&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;OutputType&gt;<\/span>WinExe<span class=\"synIdentifier\">&lt;\/OutputType&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;TargetFramework&gt;<\/span>net45<span class=\"synIdentifier\">&lt;\/TargetFramework&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;LangVersion&gt;<\/span>latest<span class=\"synIdentifier\">&lt;\/LangVersion&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;UseWPF&gt;<\/span>true<span class=\"synIdentifier\">&lt;\/UseWPF&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;EnableDefaultNoneItems&gt;<\/span>false<span class=\"synIdentifier\">&lt;\/EnableDefaultNoneItems&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;ApplicationIcon&gt;<\/span>App.ico<span class=\"synIdentifier\">&lt;\/ApplicationIcon&gt;<\/span>\u000a    <span class=\"synIdentifier\">&lt;ApplicationManifest&gt;<\/span>App.manifest<span class=\"synIdentifier\">&lt;\/ApplicationManifest&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;\/PropertyGroup&gt;<\/span>\u000a<span class=\"synIdentifier\">&lt;\/Project&gt;<\/span>\u000a<\/pre>\u000a\u000a\u000a<p>尚、前述したように UseWindowsForms および UseWPF は各ライブラリの参照設定に関するもののようなので、併記する事も可能です。WPF の場合、GUI コンポーネントが足りない等の理由で WinForms を併用する事もあるので、その場合には UseWindowsForms も true で設定します。<\/p>\u000a\u000a<h5 id=\"Include-および-Update-規則-1\">Include および Update 規則<\/h5>\u000a\u000a<p>WPF におけるソースファイル等の Include および Update 規則に関する記述内容は下記になります。<\/p>\u000a\u000a<pre class=\"code lang-xml\" data-lang=\"xml\" data-unlink><span class=\"synIdentifier\">&lt;ItemGroup&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;ApplicationDefinition <\/span><span class=\"synType\">Include<\/span>=<span class=\"synConstant\">&quot;App.xaml&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">SubType<\/span>=<span class=\"synConstant\">&quot;Designer&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">Generator<\/span>=<span class=\"synConstant\">&quot;MSBuild:Compile&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;Page <\/span><span class=\"synType\">Include<\/span>=<span class=\"synConstant\">&quot;Views\\**\\*.xaml&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">SubType<\/span>=<span class=\"synConstant\">&quot;Designer&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">Generator<\/span>=<span class=\"synConstant\">&quot;MSBuild:Compile&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;Compile <\/span><span class=\"synType\">Update<\/span>=<span class=\"synConstant\">&quot;Views\\**\\*.xaml.cs&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">SubType<\/span>=<span class=\"synConstant\">&quot;Code&quot;<\/span><span class=\"synIdentifier\"> <\/span><span class=\"synType\">DependentUpon<\/span>=<span class=\"synConstant\">&quot;%(Filename)&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;Resource <\/span><span class=\"synType\">Include<\/span>=<span class=\"synConstant\">&quot;Assets\\**\\*&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;Resource <\/span><span class=\"synType\">Include<\/span>=<span class=\"synConstant\">&quot;App.ico&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a  <span class=\"synIdentifier\">&lt;None <\/span><span class=\"synType\">Include<\/span>=<span class=\"synConstant\">&quot;App.config&quot;<\/span><span class=\"synIdentifier\"> \/&gt;<\/span>\u000a<span class=\"synIdentifier\">&lt;\/ItemGroup&gt;<\/span>\u000a<\/pre>\u000a\u000a\u000a<p>まず、App.xaml を ApplicationDefinition で明記する必要があります。次に、Page および Compile の項目で、それ以外の *.xaml ファイル（およびコードビハインドに当たる *.cs ファイル）を追加します。この時、App.xaml が同じディレクトリに存在すると重複エラーとなります。その場合は、Page の項目に対して Exclude=&quot;App.xaml&quot; と言う記述を追加して下さい。個人的には、ディレクトリ階層で区分する事で解決するようにしています。<\/p>\u000a\u000a<h4 id=\"新-csproj-具体例へのリンク一覧\">新 csproj 具体例へのリンク一覧<\/h4>\u000a\u000a<p>最後に、これまでに説明した内容を実際のプロジェクトで記述したものをサンプルとしていくつか紹介します。<\/p>\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem.SevenZip\/blob\/master\/Libraries\/Core\/Cube.FileSystem.SevenZip.csproj\">ライブラリ (Cube.FileSystem.SevenZip.csproj)<\/a><\/li>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem.SevenZip\/blob\/master\/Libraries\/Tests\/Cube.FileSystem.SevenZip.Tests.csproj\">ユニットテスト (Cube.FileSystem.SevenZip.Tests.csproj)<\/a><\/li>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem.SevenZip\/blob\/master\/Applications\/Ice\/Main\/Cube.FileSystem.SevenZip.Ice.csproj\">WinForms (Cube.FileSystem.SevenZip.Ice.csproj)<\/a><\/li>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.Net\/blob\/master\/Applications\/Rss\/Reader\/Cube.Net.Rss.Reader.csproj\">WPF (Cube.Net.Rss.Reader.csproj)<\/a><\/li>\u000a<\/ul>\u000a\u000a<div class=\"footnote\">\u000a<p class=\"footnote\"><a href=\"#fn-58da1a60\" name=\"f-58da1a60\" class=\"footnote-number\">*1<\/a><span class=\"footnote-delimiter\">:<\/span><span class=\"footnote-text\">尚、TargetFramework を netcoreapp3.0 に設定した場合、現時点では Microsoft.NET.Sdk.WindowsDesktop と記述した時点で UseWindowsForms, UseWPF の設定に関わらず全ての WinForms\/WPF ライブラリが参照に追加されるようです。<\/span><\/p>\u000a<\/div>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20190404\/vs2019-csproj","PublishTime":"\/Date(1570900928000+0900)\/","Status":1,"Summary":"2019 年 4 月 2 日、Visual Studio 2019 が正式版としてリリース (GA: General Available) されました。この記事では、 Visual Studio 2019 に関連する内容として、C# の新しいプロジェクト形式 (csproj) への移行について記載します。新 csproj 自体は Visual Studio 2017 の頃から利用可能でしたが、Wi","Title":"Visual Studio 2019 と新 csproj への移行"},{"Categories":[],"Content":"<p>2018 年も残り僅かとなりました。この記事では、私の 1 年間の活動を振り返ります。<\/p>\u000a\u000a<ul class=\"table-of-contents\">\u000a    <li><a href=\"#GitHub-Activity\">GitHub Activity<\/a><\/li>\u000a    <li><a href=\"#リポジトリおよびコードの整理\">リポジトリおよびコードの整理<\/a><\/li>\u000a    <li><a href=\"#CI-の徹底およびテストカバレッジの可視化\">CI の徹底およびテストカバレッジの可視化<\/a><\/li>\u000a    <li><a href=\"#CubePDF-シリーズの大改修\">CubePDF シリーズの大改修<\/a><\/li>\u000a<\/ul>\u000a\u000a<h4 id=\"GitHub-Activity\"><a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/GitHub\">GitHub<\/a> Activity<\/h4>\u000a\u000a<p><a href=\"https:\/\/github.com\/clown\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20181229\/20181229230942.png\" alt=\"GitHub\" \/><\/a><\/p>\u000a\u000a<p>まず、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/GitHub\">GitHub<\/a> Activity に目を向けると、2018 年は 2,321 コミット (contributions) と言う結果になりました。<a href=\"\/entry\/github-activity-2017\">GitHub の Activity を意識し始め<\/a> ておよそ 2 年が経過しましたが、特別な理由がない限り毎日コミットし続けると言う目標を今年も概ね達成できた事は何よりでした。<\/p>\u000a\u000a<p><a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%EC%A5%B3%A1%BC%A5%C7%A5%A3%A5%F3%A5%B0%A1%A6%A5%C0%A5%A4%A5%A8%A5%C3%A5%C8\">レコーディング・ダイエット<\/a>のような形で自らのコミットを記録し続けて気付いた点として、<strong>平均的に見た場合、1 日 10 コミットは想像以上に大変<\/strong> と言うものが挙げられます。もちろん、1 コミット当たりの修正量によって総作業量は変わってきますが、この事実は自分がそれまでに漠然と想像していた量よりも随分と少ないと言うのが率直な感想です。何らかのソフトウェアを開発する際にも、この事実を念頭に置きながら大雑把に見積もる事で、当初想定する期間と現実とのギャップが埋まってきたのは良い副産物であったように感じます。<\/p>\u000a\u000a<h4 id=\"リポジトリおよびコードの整理\"><a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ<\/a>およびコードの整理<\/h4>\u000a\u000a<p>2018 年は、2017 年の中頃から始まった <strong>これまで CubeSoft として公開してきたソフトウェアに対する開発サイクルの再構築<\/strong> を推し進めた年となりましたが、その中の一つに、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ<\/a>およびコードの整理があります。CubeSoft としては現在、下記の 8 個をアクティブな公開<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ<\/a>として管理しています。非公開<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ<\/a>や fork した<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ<\/a>を含めるともう少し存在しますが、ここ 2 年は多くの時間をこれらの<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ<\/a>に注いでいます。<\/p>\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.Core\">Cube.Core<\/a><\/li>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem\">Cube.FileSystem<\/a><\/li>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.FileSystem.SevenZip\">Cube.FileSystem.SevenZip<\/a> ... CubeICE<\/li>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.Images\">Cube.Images<\/a><\/li>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.Forms\">Cube.Forms<\/a><\/li>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.Xui\">Cube.Xui<\/a><\/li>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.Net\">Cube.Net<\/a> ... CubeRSS Reader<\/li>\u000a<li><a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\">Cube.Pdf<\/a> ... CubePDF Series<\/li>\u000a<\/ul>\u000a\u000a\u000a<p>コードの整理と言う観点で見ると、2018 年は <strong>コメントの一部を英語で書くように方針転換した<\/strong> 事が大きな特徴の一つです。私自身は「下手な英語よりは、まともな日本語の方がマシ」と言う価値観であるため、これまではコードのコメントも日本語で記述していました。しかし、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/Visual%20Studio\">Visual Studio<\/a> を始めとした最近の開発環境には、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/Javadoc\">Javadoc<\/a> や <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/XML\">XML<\/a> Documentation などの構造化されたコメントを解析してポップアップ表示する機能が標準搭載される事も珍しくなくなってきました。<\/p>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20181229\/20181229235022.png\" alt=\"XML Documentation\" \/><\/p>\u000a\u000a<p>このため、上記のようなコメントを日本語で記述した場合、該当コードを利用するユーザの開発環境では、そのユーザの言語設定に関わらず日本語が表示される事となります。前述した<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ<\/a>もその多くは利用可能なライブラリとして <a href=\"https:\/\/www.nuget.org\/profiles\/clown\">NuGet<\/a> に登録しており、その結果、少しずつですが海外のユーザにも試して頂けているようです。このような状況を鑑みると日本語のコメントが表示されてしまうのは好ましくないと思い、方針の転換を決定しました。<\/p>\u000a\u000a<p>方針転換に際しては当初、英語と日本語、両方のコメントを管理する事も選択肢として検討しました。しかし、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/XML\">XML<\/a> Documentation では複数言語のコメントを管理するための良い仕組みが見当たらなかった事、管理するコメント量が増えるにつれて嘘のコメントの危険性が増加する事、そして何より、私自身、まったく同じコメントが複数言語で記述された<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード<\/a>など見たくなかった事などの理由で、日本語のコメントを捨てる事にしました。2018 年現在、既存のコードには大量の日本語コメントが残ってはいますが、この辺りは少しずつ修正していこうと思います。<\/p>\u000a\u000a<h4 id=\"CI-の徹底およびテストカバレッジの可視化\">CI の徹底およびテスト<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%AB%A5%D0%A5%EC%A5%C3%A5%B8\">カバレッジ<\/a>の可視化<\/h4>\u000a\u000a<p><a href=\"https:\/\/codecov.io\/gh\/cube-soft\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20181230\/20181230004952.png\" alt=\"Codecov\" \/><\/a><\/p>\u000a\u000a<p><a href=\"\/entry\/20181106\/my-programmer-history-by-unit-test\">ユニットテストで振り返るプログラマとしての自分史<\/a> でも触れましたが、開発サイクルを再構築して大きく変わった点は <a href=\"https:\/\/www.appveyor.com\/\">AppVeyor<\/a> を利用した<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%B7%D1%C2%B3%C5%AA%A5%A4%A5%F3%A5%C6%A5%B0%A5%EC%A1%BC%A5%B7%A5%E7%A5%F3\">継続的インテグレーション<\/a> (CI: Continuous Integration) の徹底、および <a href=\"https:\/\/codecov.io\/gh\/cube-soft\">Codecov<\/a> によるテスト<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%AB%A5%D0%A5%EC%A5%C3%A5%B8\">カバレッジ<\/a>の可視化です。<\/p>\u000a\u000a<p>テスト<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%AB%A5%D0%A5%EC%A5%C3%A5%B8\">カバレッジ<\/a>の可視化に関しては、長年、自分の中にも「テスト<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%AB%A5%D0%A5%EC%A5%C3%A5%B8\">カバレッジ<\/a>の数値を気にするようになると、数値を上げるためだけの<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>を記述するようになるのではないか？」という不安が常にありました。そして実際、数値を上げる以外の意義を感じられない<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>を数多く記述し、これに何の意味があるのか……と言う感情を抱く事も何度もありました。<\/p>\u000a\u000a<p>しかし、面白い事に 2 年ほど<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%EA%A5%D5%A5%A1%A5%AF%A5%BF%A5%EA%A5%F3%A5%B0\">リファクタリング<\/a>や修正を続けていると、数値を上げる以外に意義を感じられない<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>に何度も救われる事となりました。例えば、<a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/blob\/master\/Applications\/Editor\/Tests\/Sources\/Presenters\/RibbonTest.cs\">View に表示するメニューやメッセージの文字列<\/a> などは、記述時は「定義ファイルに決め打ちで記述するのだし、テストするまでもなく明白」のような気がしていました。しかし、ある時、何らかの修正時にうっかり定義ファイルの記述位置がずれてしまい、さらに不幸な事に、ビルド時にも実行時にもエラーが発生しなかった事がありました。このケースに関しては、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>がなければ表示内容が異なっている事に、しばらく気付く事ができなかったのではないかと言う気がします。<\/p>\u000a\u000a<p>テスト<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%AB%A5%D0%A5%EC%A5%C3%A5%B8\">カバレッジ<\/a>の数値を上げるためだけの近視眼的なテストコードを記述する事によって、それよりも重要なテストコードを見逃すのではないかと言う不安は依然としてあります。ただ最近は、ある程度は仕方がないと割り切り、以下のような指針で実装およびテストコードの記述を行っています。<\/p>\u000a\u000a<ol>\u000a<li>初期リリースまでは、取り合えずテスト<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%AB%A5%D0%A5%EC%A5%C3%A5%B8\">カバレッジ<\/a>の数値（80%～95% 程度）を指標としてテストコードを記述する。この結果、初期リリース時点では、正常ケースおよび容易に予想可能な異常ケースのテストに留まる事が多い。<\/li>\u000a<li>リリース後に何らかの不都合が発覚した場合、必ず最初に該当の不都合が再現するテストコードを記述する。そして、テストを実行してレッド・シグナルを確認する。<\/li>\u000a<li>該当部分の実装コードを修正し、テストを実行してグリーン・シグナルを確認する。<\/li>\u000a<\/ol>\u000a\u000a\u000a<p>このサイクルによって、完全ではないにしても「少しずつだが、良くなってはいる」事を実感できるのは、テストコードを含めた保守を続けていく、あるいは習慣化する上でプラスに働いていると思います。<\/p>\u000a\u000a<h4 id=\"CubePDF-シリーズの大改修\">CubePDF シリーズの大改修<\/h4>\u000a\u000a<p>ソフトウェア別で見ると、2018 年は CubeSoft において最も多くの人達に利用されている <a href=\"https:\/\/www.cube-soft.jp\/cubepdf\/\">CubePDF<\/a> を始め、CubePDF シリーズの開発を継続的に続けていけるよう、様々な面において保留となっていた事柄に取り組めた 1 年であり、その意味でも充実度は高かったように思います。<\/p>\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/clown.hatenablog.jp\/entry\/20180928\/cubepdf\">CubePDF シリーズの大改修<\/a><\/li>\u000a<li><a href=\"https:\/\/clown.hatenablog.jp\/entry\/20181129\/cubepdf-and-ghostscript\">CubePDF に含まれる Ghostscript を手動で更新する方法<\/a><\/li>\u000a<li><a href=\"https:\/\/clown.hatenablog.jp\/entry\/20181126\/cubepdf-ghostscript\">Ghostscript を C# から利用するためのライブラリ<\/a><\/li>\u000a<\/ul>\u000a\u000a\u000a<p>具体的に挙げるとすると、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/GUI\">GUI<\/a> の英語化は大きな特徴の一つでしょうか。特に CubePDF に関しては、全て日本語表示であった頃から海外ユーザが存在していたようで、そう言った事も含めて複数言語の View を開発するためのパターンが自分の中で確立できたのは良かったと思います。<\/p>\u000a\u000a<p>また、CubePDF には <a href=\"https:\/\/github.com\/cube-soft\/Cube.Pdf\/blob\/master\/Applications\/Converter\/Document.ja.md\">ユーザーズマニュアル<\/a> と言う PDF を同梱していますが、この基となるドキュメントを <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/markdown\">markdown<\/a> 形式で書き直す事でバージョン管理に含められるようになったのも、個人的には満足した出来事です。<\/p>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20181230\/activity","PublishTime":"\/Date(1570898392000+0900)\/","Status":2,"Summary":"2018 年も残り僅かとなりました。この記事では、私の 1 年間の活動を振り返ります。 GitHub Activity リポジトリおよびコードの整理 CI の徹底およびテストカバレッジの可視化 CubePDF シリーズの大改修 GitHub Activity まず、GitHub Activity に目を向けると、2018 年は 2,321 コミット (contributions) と言う結果になり","Title":"2018 年の振り返り"},{"Categories":[],"Content":"<p>ここ 1, 2 年、主に <a href=\"https:\/\/www.cube-soft.jp\/\">キューブ・ソフト<\/a> で配布している <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/Windows\">Windows<\/a> ソフトウェアを中心に、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>周りの整備を精力的に行ってきました。今回は、テストと言う視点で、自らのプログラミングの軌跡を振り返るような記事を執筆してみようかと思います。<\/p>\u000a\u000a<ul class=\"table-of-contents\">\u000a    <li><a href=\"#テスト以前\">テスト以前<\/a><\/li>\u000a    <li><a href=\"#Edit-and-Pray-からの脱却\">Edit and Pray からの脱却<\/a><\/li>\u000a    <li><a href=\"#はじめてのユニットテスト\">はじめてのユニットテスト<\/a><\/li>\u000a    <li><a href=\"#Ruby-を用いた-Web-サービスと-RSpec\">Ruby を用いた Web サービスと RSpec<\/a><\/li>\u000a    <li><a href=\"#PDS-とアプリケーションのユニットテスト\">PDS とアプリケーションのユニットテスト<\/a><\/li>\u000a    <li><a href=\"#開発をサポートする-Web-サービスの拡充\">開発をサポートする Web サービスの拡充<\/a><\/li>\u000a<\/ul>\u000a\u000a<h4 id=\"テスト以前\">テスト以前<\/h4>\u000a\u000a<p>私の<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DE\">プログラマ<\/a>としての経歴は 2001 年 4 月に大学の<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%BE%F0%CA%F3%B2%CA%B3%D8\">情報科学<\/a>科に入学した事によって始まります。入学するまではプログラミングの経験もなく、本当にゼロからのスタートでした。入学<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A4%AB%A4%E9%A4%B7\">からし<\/a>ばらくの間は、講義で出される課題を解いていく日々と言う感じで、触れた<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語<\/a>こそ、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/Pascal\">Pascal<\/a>、C、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/Java\">Java<\/a>、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/CASL\">CASL<\/a> II、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/Perl\">Perl<\/a>、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/Standard%20ML\">Standard ML<\/a>、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/VHDL\">VHDL<\/a> と多岐に渡りますが、実際には書き捨てのプログラムが大多数を占めていました。<\/p>\u000a\u000a<p>この記事を書くにあたり、何か当時の成果が残っていないかバックアップ HDD を漁ったところ、<a href=\"https:\/\/github.com\/clown\/rovnd\">ROVND<\/a> と言うプロジェクトを発見しました。私は <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/RAGNAROK%20Online\">RAGNAROK Online<\/a> と言う <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/MMORPG\">MMORPG<\/a> の最初期に「ゲーム内（Loki から <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/Heimdal\">Heimdal<\/a> サーバ）で取引されるアイテムの相場を調査して公開する」と言う事を行っていましたが、時が経ち、ゲーム内で流通するアイテムの種類が増えていくにつれて、手動による更新に限界を感じ始めていました。そこで、プログラムによる半自動化を試みたのが最初のプロジェクトとなります。内容的には、<a href=\"https:\/\/github.com\/clown\/rovnd\/blob\/master\/price.txt\">価格データ (price.txt)<\/a> 等の内容を基に、静的な HTML を生成するものです<a href=\"#f-b90dfc13\" name=\"fn-b90dfc13\" title=\"プログラムが足りないような気がするのですが、残念ながら、これ以外のプログラムをサルベージする事はできませんでした。\">*1<\/a>。日付を見ると、2002 年～ 2003 年の終わり頃まで続けていたようです。<\/p>\u000a\u000a<p>ROVND はテキスト処理を C のみで行うと言う、今考えると茨の道を選択していますが、困ってから根性で何とかすると言うスタンスで、最初の数年は過ぎていきました。この頃は、テストどころか保守と言う概念すらありません。バージョン管理と言う概念を知るのもまだまだ先の事です。<\/p>\u000a\u000a<h4 id=\"Edit-and-Pray-からの脱却\">Edit and Pray からの脱却<\/h4>\u000a\u000a<p><a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DE\">プログラマ<\/a>として最初の転換期となったのが 2004 年です。この年、初めて講義とは関係なく、自らの意思で <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/C%2B%2B\">C++<\/a> の学習を始めました。始めた理由は、何となくカッコイイからと言う程度のものだったのですが、学習し始めると同時に何故か「汎用的な <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/C%2B%2B\">C++<\/a> ライブラリ」を作り始めます。これが後に <a href=\"http:\/\/clx.cielquis.net\/\">CLX C++ Libraries<\/a> と言う名前となり、公開している中で最初の成果物となりました。記録を見ると初公開は 2006 年 2 月 22 日だそうなので、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DE\">プログラマ<\/a>になって 6 年目と言う事になります。<\/p>\u000a\u000a<p>CLX <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/C%2B%2B\">C++<\/a> Libraries は、私にとって思い出深いものとなりました<a href=\"#f-ec8baf70\" name=\"fn-ec8baf70\" title=\"メインとするプログラミング言語が C# になった等の都合で、残念ながら、現在は保守をしていません。\">*2<\/a>。2008 年に OSDN（旧 <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/SourceForge.JP\">SourceForge.JP<\/a>）より <a href=\"https:\/\/ja.osdn.net\/projects\/sourceforge\/wiki\/potm_0808_CLXCPP\">今月のプロジェクト<\/a> として取り上げて頂いた時には、初めて自分のプログラムが注目されて嬉しかった事を覚えています。また、このプロジェクトのおかげか <a href=\"https:\/\/twitter.com\/cpp_akira\">@cpp_akira<\/a> さんに Boost.勉強会等に誘って頂き、日本における <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/C%2B%2B\">C++<\/a> のコミュニティについても知る事ができました。<\/p>\u000a\u000a<p>プログラミングに関する基本的なスタンスや <a href=\"https:\/\/ja.osdn.net\/projects\/clxcpp\/scm\/svn\/commits\/1\">バージョン管理<\/a> への理解なども、このプロジェクトを通じて徐々に固まっていきました。しかし、<strong>自分以外の誰かが自分のプログラムを利用する<\/strong> と言う状況になり、遂に保守に関する問題が露呈し始めます。CLX <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/C%2B%2B\">C++<\/a> Libraries は、自分の思い付きでライブラリを追加・修正していましたが、少しずつ「公開されているサンプルファイルすら動かない」と言う報告を頂くようになりました。<\/p>\u000a\u000a<p><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20190204\/20190204101038.png\" alt=\"ソフトウェア開発の失敗談\" \/><\/p>\u000a\u000a<p>修正した部分に関しては手動による確認を行っていたのですが、「まさかそんな所に影響があるとは……」と思うようなファイルに対して、エラーが見つかる事が多々ありました。自分が完全に把握していると思っているプロジェクトですらこの有様なのだと、プログラミングに対する恐ろしさを教えてくれたプロジェクトでもあります。<\/p>\u000a\u000a<p>この時点では、まだ「<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>」と言う概念は知りませんでしたが、何とかしなければと言う危機感はありました。しばらくの間、この問題に対して悩んだ結果、ライブラリと一緒に作成していたサンプルファイルを利用する事を思いつきます。CLX プロジェクトでは、新たなライブラリを追加すると、そのライブラリを利用するための簡単なサンプルコードも併せて作成する形で更新を続けており、この時点で 100 ファイル程度のサンプルファイルが手元に存在しました。そこで、これらのサンプルファイルを下記のような<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%B7%A5%A7%A5%EB%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">シェルスクリプト<\/a>で全て実行し、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル<\/a>エラーが存在しないかどうかを確認する事でテストとする方針にしました。<\/p>\u000a\u000a<pre class=\"code lang-csh\" data-lang=\"csh\" data-unlink>for file in <span class=\"synStatement\">`ls example\/*.cpp`<\/span>; do\u000a    command=<span class=\"synConstant\">&quot;<\/span><span class=\"synType\">$CC<\/span><span class=\"synConstant\"> <\/span><span class=\"synType\">$CFLAGS<\/span><span class=\"synConstant\"> <\/span><span class=\"synType\">$file<\/span><span class=\"synConstant\"> <\/span><span class=\"synType\">$LDFLAGS<\/span><span class=\"synConstant\">&quot;<\/span>\u000a    <span class=\"synType\">$command<\/span> <span class=\"synConstant\">2<\/span><span class=\"synStatement\">&gt;<\/span><span class=\"synType\">$TMPLOG<\/span> <span class=\"synStatement\">&gt;<\/span>\/dev\/null\u000a    <span class=\"synStatement\">if<\/span> [ <span class=\"synStatement\">-<\/span>e <span class=\"synType\">$TMPLOG<\/span> <span class=\"synStatement\">-<\/span>a <span class=\"synStatement\">-<\/span>s <span class=\"synType\">$TMPLOG<\/span> ]; <span class=\"synStatement\">then<\/span>\u000a        cat <span class=\"synType\">$TMPLOG<\/span> <span class=\"synStatement\">&gt;&gt;<\/span><span class=\"synType\">$ERRLOG<\/span>\u000a    fi\u000adone\u000a<\/pre>\u000a\u000a\u000a<p>対象とする<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ<\/a>は <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/GCC\">GCC<\/a>、Visual <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/C%2B%2B\">C++<\/a>、および <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/Borland\">Borland<\/a> <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/C%2B%2B\">C++<\/a> でしたが、全ての<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ<\/a>に対して毎回<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル<\/a>を実行すると数 10 分程度の時間を要していたため、実際には、通常時は <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/GCC\">GCC<\/a> のみでリリース前のみ全ての<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ<\/a>で検査する形を採用していました。これにより、完全なテストとは言えないまでも単純な<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル<\/a>エラーは検知できるようになり、何もしないよりはマシと言うレベルには改善する事ができました。<\/p>\u000a\u000a<h4 id=\"はじめてのユニットテスト\">はじめての<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a><\/h4>\u000a\u000a<p>2009 年頃から、利用者数的には恐らく最大の成果物となる <a href=\"https:\/\/www.cube-soft.jp\/\">CubePDF<\/a> の開発がスタートしました。私自身は、ちょうどこの前後で<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>と言う概念を知ったため、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/C%23\">C#<\/a> による開発では比較的早い段階から <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/NUnit\">NUnit<\/a> を利用した<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>を用意する事に成功しています。しかし、この時点では少なくとも 2 つの問題が存在しました。1 点目は見た目と処理の分離 (<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/PDS\">PDS<\/a>: Presentation Domain Separation) と言う原則が理解できていなかったため View に近い部分の<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>が書けずにいた事、そして 2 点目はテスト時間です。<\/p>\u000a\u000a<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink>[Test]\u000a<span class=\"synType\">public<\/span> <span class=\"synType\">void<\/span> TestConvertFileType() {\u000a    <span class=\"synStatement\">foreach<\/span> (Parameter.FileTypes type <span class=\"synStatement\">in<\/span> Enum.GetValues(...)) {\u000a        UserSetting setting = <span class=\"synStatement\">new<\/span> UserSetting();\u000a        setting.FileType = type;\u000a        setting.PostProcess = Parameter.PostProcesses.None;\u000a        ExecConvert(setting, <span class=\"synConstant\">&quot;-type&quot;<\/span>);\u000a    }\u000a}\u000a\u000a<span class=\"synType\">private<\/span> <span class=\"synType\">void<\/span> ExecConvert(UserSetting setting, <span class=\"synType\">string<\/span> suffix) {\u000a    <span class=\"synType\">string<\/span> output = System.Environment.CurrentDirectory + <span class=\"synSpecial\">@<\/span><span class=\"synConstant\">&quot;\\\\results&quot;<\/span>;\u000a    <span class=\"synStatement\">foreach<\/span> (<span class=\"synType\">string<\/span> file <span class=\"synStatement\">in<\/span> Directory.GetFiles(<span class=\"synConstant\">&quot;examples&quot;<\/span>, <span class=\"synConstant\">&quot;*.ps&quot;<\/span>)) {\u000a        <span class=\"synComment\">\/* ... *\/<\/span>\u000a        <span class=\"synType\">bool<\/span> status = File.Exists(setting.OutputPath);\u000a        Assert.IsTrue(status, <span class=\"synConstant\">&quot;File.Exists: &quot;<\/span> + file);\u000a    }\u000a}\u000a<\/pre>\u000a\u000a\u000a<p>上記は CubePDF における変換処理の<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>の一部です。これらの<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>を記述した当初は、事前に用意したいくつかの PostScript ファイルに対して、<strong>CubePDF で取り得る全ての設定でテストする事<\/strong> を目的としていたのですが、1 つのテストケースに対して 1 分以上の時間を要すると言うとんでもないテストコードとなりました。<\/p>\u000a\u000a<blockquote><p>テストを実行して成功した後、小さな変更をしてテストが失敗したら、問題の原因がどこにあるかを正確に知ることができる。それは、今しがた実施した小さな変更のどれかなので、変更を元に戻してやり直すことができる。しかしテストが大きければ、実行時間は非常に長くなってしまう。このため、エラー箇所を特定できるまで頻繁にテストを実行するのを、つい避けてしまいがちになる。<\/p>\u000a\u000a<p><a href=\"https:\/\/amzn.to\/2D3QB5G\">Michael C. Feathers, “レガシーコード改善ガイド” (p.15)<\/a><\/p><\/blockquote>\u000a\u000a<p>CubePDF は、どちらかと言えばかなりテスト規模の小さな部類に入ると予想されますが、上記のようなテストケースが大量に存在していたため、毎回のテスト実行が非常に億劫になる現象を引き起こしました。この失敗で得られた教訓は、最悪でも選択的なテスト実行においては余計な時間を取られないよう、少なくとも foreach 内の各テストが単一のテストケースとなるように記述を工夫すべきと言うものでした。<\/p>\u000a\u000a<h4 id=\"Ruby-を用いた-Web-サービスと-RSpec\"><a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/Ruby\">Ruby<\/a> を用いた Web サービスと <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/RSpec\">RSpec<\/a><\/h4>\u000a\u000a<p>CubePDF のリリース後、2011 年には <a href=\"https:\/\/www.cube-soft.jp\/cubeice\/\">CubeICE<\/a>、2013 年には <a href=\"https:\/\/www.cube-soft.jp\/cubepdfutility\/\">CubePDF Utility<\/a> と、利用者数的には現在でもキューブ・ソフトの主力となるソフトウェアをリリースしていますが、後から振り返ってみると、個人的な開発スタイルとしては停滞期を迎えた時期でした（もちろん、その時、その時では、頑張っているつもりでしたが）。<\/p>\u000a\u000a<p>この頃、キューブ・ソフトでの開発と並行して個人的なプロジェクトである Web サービスの開発・運営にも取り組んでおり、この時の成果物が <a href=\"http:\/\/sogap.cielquis.net\/\">SoGap<\/a> となります。SoGap は、複数の<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%BD%A1%BC%A5%B7%A5%E3%A5%EB%A5%E1%A5%C7%A5%A3%A5%A2\">ソーシャルメディア<\/a>（ここでは、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A4%CF%A4%C6%A4%CA%A5%D6%A5%C3%A5%AF%A5%DE%A1%BC%A5%AF\">はてなブックマーク<\/a>、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/Twitter\">Twitter<\/a> 、および <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/Facebook\">Facebook<\/a>）のいずれでも話題になっている記事を除外する事によって、各<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%BD%A1%BC%A5%B7%A5%E3%A5%EB%A5%E1%A5%C7%A5%A3%A5%A2\">ソーシャルメディア<\/a>でのみ話題になっているニッチなものを探そうと言うコンセプトで、概要および SoGap で取得したデータを用いた解析に関しては <a href=\"https:\/\/link.springer.com\/chapter\/10.1007\/978-3-319-42345-6_21\">Proposal of a New Social Signal for Excluding Common Web Pages in Multiple Social Networking Services<\/a> と言う論文にまとまっています。ただ、残念ながら諸々の都合で、2015 年 11 月 20 日をもって SoGap の更新は終了しました。<\/p>\u000a\u000a<p>この Web サービスの開発時に利用したのが <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/RSpec\">RSpec<\/a> でした。私自身は Spec と言う概念を正確には把握しておらず、単に<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>・<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク<\/a>の一つとして利用していたのですが、上手く記述すると実行した時に英語として読める形で結果が出力されていく様は、書いていて楽しいかもと思わせる魅力でもありました。<\/p>\u000a\u000a<p><a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/RSpec\">RSpec<\/a> に関する記事で学んだ事は、単一のテストケースに含まれる Assert の数はできるだけ少なくすべきと言うものでした。特に、for 文中の各要素に対して Assert が実行されるような状況でテストが失敗すると、どの部分が失敗したのか判別するのが困難になるので良くないと言う指摘は、なるほど確かにと納得した事を覚えています。<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/RSpec\">RSpec<\/a> に関する記事では 1 テスト 1 Assert と言う主張も見られ、さすがにそこまでは厳しいですが、失敗した時に判別できるようにメッセージ等を工夫するなど、それまであまり気にしていなかった点に気付けた事は、テストと言う観点から見ても良かったと思います。<\/p>\u000a\u000a<h4 id=\"PDS-とアプリケーションのユニットテスト\"><a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/PDS\">PDS<\/a> とアプリケーションの<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a><\/h4>\u000a\u000a<p>再び <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/C%23\">C#<\/a> の開発に目を戻します。<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/C%23\">C#<\/a> による開発では長年、アプリケーションに近い部分の<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>を何とかしたいと言う思いがあり、2014 年頃にようやく Presentation Domain Separation (<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/PDS\">PDS<\/a>) と言う概念にたどり着きます。最初は非公開としているプロジェクトの<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%EA%A5%D5%A5%A1%A5%AF%A5%BF%A5%EA%A5%F3%A5%B0\">リファクタリング<\/a>時に適用したのですが、何度か失敗した後、公開しているプロジェクトにも適用する事に成功しました。これらの詳細に関しては、下記の記事を参照下さい。<\/p>\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/clown.hatenablog.jp\/entry\/cubeice\">圧縮・解凍ソフト CubeICE をゼロから改修<\/a><\/li>\u000a<li><a href=\"https:\/\/clown.hatenablog.jp\/entry\/20180928\/cubepdf\">CubePDF シリーズの大改修<\/a><\/li>\u000a<\/ul>\u000a\u000a\u000a<p>適用したパターンは、それぞれのソフトウェア毎に微妙に異なりますが、CubeICE の<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%EA%A5%D5%A5%A1%A5%AF%A5%BF%A5%EA%A5%F3%A5%B0\">リファクタリング<\/a>以降は概ね View 以外は<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>でカバーできる形になりました。View 部分の<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>は相変わらずの懸念事項です。<a href=\"https:\/\/github.com\/Codeer-Software\/Friendly\">Friendly<\/a> と言う<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク<\/a>を用いた View テストの発表・実演を何度か見て、非常に良さそうと言う印象を抱いているので、折を見て試してみようとは思っています。<\/p>\u000a\u000a<h4 id=\"開発をサポートする-Web-サービスの拡充\">開発をサポートする Web サービスの拡充<\/h4>\u000a\u000a<p>2018 年現在までたどり着きました。ここ 1, 2 年、開発面で大きく前進したと実感できるのは <a href=\"https:\/\/ci.appveyor.com\/\">AppVeyor<\/a> や <a href=\"https:\/\/codecov.io\/gh\/cube-soft\">Codecov<\/a> と言った開発をサポートする Web サービスの存在が非常に大きいと感じます。現在では、キューブ・ソフトで開発しているソフトウェアおよびライブラリのかなりの部分まで Continuous Integration (CI) の実現に成功し、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%E6%A5%CB%A5%C3%A5%C8%A5%C6%A5%B9%A5%C8\">ユニットテスト<\/a>の<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%AB%A5%D0%A5%EC%A5%C3%A5%B8\">カバレッジ<\/a>等も分かりやすく閲覧する事ができます。かつてであれば、対応するパッケージを自らのサーバにインストールする所から始めなければならなかったのが、ボタン一つで多くの作業が終了してしまうのは、利用者から見れば非常に大きなメリットです。<\/p>\u000a\u000a<p><a href=\"https:\/\/codecov.io\/gh\/cube-soft\"><img src=\"https:\/\/cdn-ak.f.st-hatena.com\/images\/fotolife\/t\/tt_clown\/20181230\/20181230004952.png\" alt=\"Codecov\" \/><\/a><\/p>\u000a\u000a<p>Web サービスを利用する事によって<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%AB%A5%D0%A5%EC%A5%C3%A5%B8\">カバレッジ<\/a>と言う指標に対する見方も変わりました。<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%AB%A5%D0%A5%EC%A5%C3%A5%B8\">カバレッジ<\/a>と言う指標は必ずしもソフトウェアの品質を保証するものではありませんが、後々テストを追加していく時のための枠組みとして、取り合えずこの辺りまではやっておくと言う指標程度には利用できると感じています。また、行単位でテスト状況が確認できると言うのは非常に便利で、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%AB%A5%D0%A5%EC%A5%C3%A5%B8\">カバレッジ<\/a>と言う数値自体は置いておくとしても、この機能だけでも利用する価値はあるように思います。これらの詳細な感想については、下記も参照下さい。<\/p>\u000a\u000a<ul>\u000a<li><a href=\"https:\/\/clown.hatenablog.jp\/entry\/20180511\/service-for-windows-developer\">Windows アプリ開発で利用している Web サービス<\/a><\/li>\u000a<\/ul>\u000a\u000a\u000a<p>以上、これまでの自分の経験を主にテストと言う観点でまとめてみました。<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/PDS\">PDS<\/a> と言う概念にたどり着くまで、プログラミングを始めて 15 年程度、<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/GUI\">GUI<\/a> プログラミングを開始してからでも 4, 5 年かかっている等、改めて振り返ると恥ずかしい部分も多々ありました。また、現在でも、よく分かっていないと感じる事の方が多い状態ですが、これからも少しずつ解決していければと思います。<\/p>\u000a<div class=\"footnote\">\u000a<p class=\"footnote\"><a href=\"#fn-b90dfc13\" name=\"f-b90dfc13\" class=\"footnote-number\">*1<\/a><span class=\"footnote-delimiter\">:<\/span><span class=\"footnote-text\">プログラムが足りないような気がするのですが、残念ながら、これ以外のプログラムをサルベージする事はできませんでした。<\/span><\/p>\u000a<p class=\"footnote\"><a href=\"#fn-ec8baf70\" name=\"f-ec8baf70\" class=\"footnote-number\">*2<\/a><span class=\"footnote-delimiter\">:<\/span><span class=\"footnote-text\">メインとする<a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/%A5%D7%A5%ED%A5%B0%A5%E9%A5%DF%A5%F3%A5%B0%B8%C0%B8%EC\">プログラミング言語<\/a>が <a class=\"keyword\" href=\"http:\/\/d.hatena.ne.jp\/keyword\/C%23\">C#<\/a> になった等の都合で、残念ながら、現在は保守をしていません。<\/span><\/p>\u000a<\/div>","Link":"https:\/\/clown.cube-soft.jp\/entry\/20181106\/my-programmer-history-by-unit-test","PublishTime":"\/Date(1570898392000+0900)\/","Status":2,"Summary":"ここ 1, 2 年、主に キューブ・ソフト で配布している Windows ソフトウェアを中心に、ユニットテスト周りの整備を精力的に行ってきました。今回は、テストと言う視点で、自らのプログラミングの軌跡を振り返るような記事を執筆してみようかと思います。 テスト以前 Edit and Pray からの脱却 はじめてのユニットテスト Ruby を用いた Web サービスと RSpec PDS とアプリ","Title":"ユニットテストで振り返るプログラマとしての自分史"}],"LastChecked":"\/Date(1573455849182+0900)\/","LastPublished":"\/Date(1573210603000+0900)\/","Link":"https:\/\/clown.cube-soft.jp\/","Title":"Life like a clown","Uri":"https:\/\/clown.cube-soft.jp\/feed"}